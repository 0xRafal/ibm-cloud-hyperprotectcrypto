// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: server.proto

package grep11

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/googleapis/google/api"
import _ "github.com/gogo/protobuf/gogoproto"

import github_com_ibm_developer_ibm_cloud_hyperprotectcrypto_golang_ep11 "github.com/ibm-developer/ibm-cloud-hyperprotectcrypto/golang/ep11"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type GenerateRandomRequest struct {
	Len                  uint64   `protobuf:"varint,1,opt,name=Len,proto3" json:"Len,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GenerateRandomRequest) Reset()         { *m = GenerateRandomRequest{} }
func (m *GenerateRandomRequest) String() string { return proto.CompactTextString(m) }
func (*GenerateRandomRequest) ProtoMessage()    {}
func (*GenerateRandomRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{0}
}
func (m *GenerateRandomRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GenerateRandomRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GenerateRandomRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GenerateRandomRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenerateRandomRequest.Merge(dst, src)
}
func (m *GenerateRandomRequest) XXX_Size() int {
	return m.Size()
}
func (m *GenerateRandomRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GenerateRandomRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GenerateRandomRequest proto.InternalMessageInfo

func (m *GenerateRandomRequest) GetLen() uint64 {
	if m != nil {
		return m.Len
	}
	return 0
}

type GenerateRandomResponse struct {
	Rnd                  []byte   `protobuf:"bytes,1,opt,name=Rnd,proto3" json:"Rnd,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GenerateRandomResponse) Reset()         { *m = GenerateRandomResponse{} }
func (m *GenerateRandomResponse) String() string { return proto.CompactTextString(m) }
func (*GenerateRandomResponse) ProtoMessage()    {}
func (*GenerateRandomResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{1}
}
func (m *GenerateRandomResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GenerateRandomResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GenerateRandomResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GenerateRandomResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenerateRandomResponse.Merge(dst, src)
}
func (m *GenerateRandomResponse) XXX_Size() int {
	return m.Size()
}
func (m *GenerateRandomResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GenerateRandomResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GenerateRandomResponse proto.InternalMessageInfo

func (m *GenerateRandomResponse) GetRnd() []byte {
	if m != nil {
		return m.Rnd
	}
	return nil
}

type DigestInitRequest struct {
	Mech                 *Mechanism `protobuf:"bytes,2,opt,name=Mech" json:"Mech,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *DigestInitRequest) Reset()         { *m = DigestInitRequest{} }
func (m *DigestInitRequest) String() string { return proto.CompactTextString(m) }
func (*DigestInitRequest) ProtoMessage()    {}
func (*DigestInitRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{2}
}
func (m *DigestInitRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DigestInitRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DigestInitRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DigestInitRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DigestInitRequest.Merge(dst, src)
}
func (m *DigestInitRequest) XXX_Size() int {
	return m.Size()
}
func (m *DigestInitRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DigestInitRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DigestInitRequest proto.InternalMessageInfo

func (m *DigestInitRequest) GetMech() *Mechanism {
	if m != nil {
		return m.Mech
	}
	return nil
}

type DigestInitResponse struct {
	State                []byte   `protobuf:"bytes,1,opt,name=State,proto3" json:"State,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DigestInitResponse) Reset()         { *m = DigestInitResponse{} }
func (m *DigestInitResponse) String() string { return proto.CompactTextString(m) }
func (*DigestInitResponse) ProtoMessage()    {}
func (*DigestInitResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{3}
}
func (m *DigestInitResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DigestInitResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DigestInitResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DigestInitResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DigestInitResponse.Merge(dst, src)
}
func (m *DigestInitResponse) XXX_Size() int {
	return m.Size()
}
func (m *DigestInitResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DigestInitResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DigestInitResponse proto.InternalMessageInfo

func (m *DigestInitResponse) GetState() []byte {
	if m != nil {
		return m.State
	}
	return nil
}

type DigestRequest struct {
	State                []byte   `protobuf:"bytes,1,opt,name=State,proto3" json:"State,omitempty"`
	Data                 []byte   `protobuf:"bytes,2,opt,name=Data,proto3" json:"Data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DigestRequest) Reset()         { *m = DigestRequest{} }
func (m *DigestRequest) String() string { return proto.CompactTextString(m) }
func (*DigestRequest) ProtoMessage()    {}
func (*DigestRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{4}
}
func (m *DigestRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DigestRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DigestRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DigestRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DigestRequest.Merge(dst, src)
}
func (m *DigestRequest) XXX_Size() int {
	return m.Size()
}
func (m *DigestRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DigestRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DigestRequest proto.InternalMessageInfo

func (m *DigestRequest) GetState() []byte {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *DigestRequest) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type DigestResponse struct {
	Digest               []byte   `protobuf:"bytes,3,opt,name=Digest,proto3" json:"Digest,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DigestResponse) Reset()         { *m = DigestResponse{} }
func (m *DigestResponse) String() string { return proto.CompactTextString(m) }
func (*DigestResponse) ProtoMessage()    {}
func (*DigestResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{5}
}
func (m *DigestResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DigestResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DigestResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DigestResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DigestResponse.Merge(dst, src)
}
func (m *DigestResponse) XXX_Size() int {
	return m.Size()
}
func (m *DigestResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DigestResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DigestResponse proto.InternalMessageInfo

func (m *DigestResponse) GetDigest() []byte {
	if m != nil {
		return m.Digest
	}
	return nil
}

type DigestUpdateRequest struct {
	State                []byte   `protobuf:"bytes,1,opt,name=State,proto3" json:"State,omitempty"`
	Data                 []byte   `protobuf:"bytes,2,opt,name=Data,proto3" json:"Data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DigestUpdateRequest) Reset()         { *m = DigestUpdateRequest{} }
func (m *DigestUpdateRequest) String() string { return proto.CompactTextString(m) }
func (*DigestUpdateRequest) ProtoMessage()    {}
func (*DigestUpdateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{6}
}
func (m *DigestUpdateRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DigestUpdateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DigestUpdateRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DigestUpdateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DigestUpdateRequest.Merge(dst, src)
}
func (m *DigestUpdateRequest) XXX_Size() int {
	return m.Size()
}
func (m *DigestUpdateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DigestUpdateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DigestUpdateRequest proto.InternalMessageInfo

func (m *DigestUpdateRequest) GetState() []byte {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *DigestUpdateRequest) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type DigestUpdateResponse struct {
	State                []byte   `protobuf:"bytes,1,opt,name=State,proto3" json:"State,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DigestUpdateResponse) Reset()         { *m = DigestUpdateResponse{} }
func (m *DigestUpdateResponse) String() string { return proto.CompactTextString(m) }
func (*DigestUpdateResponse) ProtoMessage()    {}
func (*DigestUpdateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{7}
}
func (m *DigestUpdateResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DigestUpdateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DigestUpdateResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DigestUpdateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DigestUpdateResponse.Merge(dst, src)
}
func (m *DigestUpdateResponse) XXX_Size() int {
	return m.Size()
}
func (m *DigestUpdateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DigestUpdateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DigestUpdateResponse proto.InternalMessageInfo

func (m *DigestUpdateResponse) GetState() []byte {
	if m != nil {
		return m.State
	}
	return nil
}

type DigestKeyRequest struct {
	State                []byte   `protobuf:"bytes,1,opt,name=State,proto3" json:"State,omitempty"`
	Key                  []byte   `protobuf:"bytes,2,opt,name=Key,proto3" json:"Key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DigestKeyRequest) Reset()         { *m = DigestKeyRequest{} }
func (m *DigestKeyRequest) String() string { return proto.CompactTextString(m) }
func (*DigestKeyRequest) ProtoMessage()    {}
func (*DigestKeyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{8}
}
func (m *DigestKeyRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DigestKeyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DigestKeyRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DigestKeyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DigestKeyRequest.Merge(dst, src)
}
func (m *DigestKeyRequest) XXX_Size() int {
	return m.Size()
}
func (m *DigestKeyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DigestKeyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DigestKeyRequest proto.InternalMessageInfo

func (m *DigestKeyRequest) GetState() []byte {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *DigestKeyRequest) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

type DigestKeyResponse struct {
	State                []byte   `protobuf:"bytes,1,opt,name=State,proto3" json:"State,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DigestKeyResponse) Reset()         { *m = DigestKeyResponse{} }
func (m *DigestKeyResponse) String() string { return proto.CompactTextString(m) }
func (*DigestKeyResponse) ProtoMessage()    {}
func (*DigestKeyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{9}
}
func (m *DigestKeyResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DigestKeyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DigestKeyResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DigestKeyResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DigestKeyResponse.Merge(dst, src)
}
func (m *DigestKeyResponse) XXX_Size() int {
	return m.Size()
}
func (m *DigestKeyResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DigestKeyResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DigestKeyResponse proto.InternalMessageInfo

func (m *DigestKeyResponse) GetState() []byte {
	if m != nil {
		return m.State
	}
	return nil
}

type DigestFinalRequest struct {
	State                []byte   `protobuf:"bytes,1,opt,name=State,proto3" json:"State,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DigestFinalRequest) Reset()         { *m = DigestFinalRequest{} }
func (m *DigestFinalRequest) String() string { return proto.CompactTextString(m) }
func (*DigestFinalRequest) ProtoMessage()    {}
func (*DigestFinalRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{10}
}
func (m *DigestFinalRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DigestFinalRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DigestFinalRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DigestFinalRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DigestFinalRequest.Merge(dst, src)
}
func (m *DigestFinalRequest) XXX_Size() int {
	return m.Size()
}
func (m *DigestFinalRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DigestFinalRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DigestFinalRequest proto.InternalMessageInfo

func (m *DigestFinalRequest) GetState() []byte {
	if m != nil {
		return m.State
	}
	return nil
}

type DigestFinalResponse struct {
	Digest               []byte   `protobuf:"bytes,2,opt,name=Digest,proto3" json:"Digest,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DigestFinalResponse) Reset()         { *m = DigestFinalResponse{} }
func (m *DigestFinalResponse) String() string { return proto.CompactTextString(m) }
func (*DigestFinalResponse) ProtoMessage()    {}
func (*DigestFinalResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{11}
}
func (m *DigestFinalResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DigestFinalResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DigestFinalResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DigestFinalResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DigestFinalResponse.Merge(dst, src)
}
func (m *DigestFinalResponse) XXX_Size() int {
	return m.Size()
}
func (m *DigestFinalResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DigestFinalResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DigestFinalResponse proto.InternalMessageInfo

func (m *DigestFinalResponse) GetDigest() []byte {
	if m != nil {
		return m.Digest
	}
	return nil
}

type DigestSingleRequest struct {
	Mech                 *Mechanism `protobuf:"bytes,1,opt,name=Mech" json:"Mech,omitempty"`
	Data                 []byte     `protobuf:"bytes,2,opt,name=Data,proto3" json:"Data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *DigestSingleRequest) Reset()         { *m = DigestSingleRequest{} }
func (m *DigestSingleRequest) String() string { return proto.CompactTextString(m) }
func (*DigestSingleRequest) ProtoMessage()    {}
func (*DigestSingleRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{12}
}
func (m *DigestSingleRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DigestSingleRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DigestSingleRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DigestSingleRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DigestSingleRequest.Merge(dst, src)
}
func (m *DigestSingleRequest) XXX_Size() int {
	return m.Size()
}
func (m *DigestSingleRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DigestSingleRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DigestSingleRequest proto.InternalMessageInfo

func (m *DigestSingleRequest) GetMech() *Mechanism {
	if m != nil {
		return m.Mech
	}
	return nil
}

func (m *DigestSingleRequest) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type DigestSingleResponse struct {
	Digest               []byte   `protobuf:"bytes,3,opt,name=Digest,proto3" json:"Digest,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DigestSingleResponse) Reset()         { *m = DigestSingleResponse{} }
func (m *DigestSingleResponse) String() string { return proto.CompactTextString(m) }
func (*DigestSingleResponse) ProtoMessage()    {}
func (*DigestSingleResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{13}
}
func (m *DigestSingleResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DigestSingleResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DigestSingleResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DigestSingleResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DigestSingleResponse.Merge(dst, src)
}
func (m *DigestSingleResponse) XXX_Size() int {
	return m.Size()
}
func (m *DigestSingleResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DigestSingleResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DigestSingleResponse proto.InternalMessageInfo

func (m *DigestSingleResponse) GetDigest() []byte {
	if m != nil {
		return m.Digest
	}
	return nil
}

type EncryptInitRequest struct {
	Mech                 *Mechanism `protobuf:"bytes,2,opt,name=Mech" json:"Mech,omitempty"`
	Key                  []byte     `protobuf:"bytes,3,opt,name=Key,proto3" json:"Key,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *EncryptInitRequest) Reset()         { *m = EncryptInitRequest{} }
func (m *EncryptInitRequest) String() string { return proto.CompactTextString(m) }
func (*EncryptInitRequest) ProtoMessage()    {}
func (*EncryptInitRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{14}
}
func (m *EncryptInitRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EncryptInitRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EncryptInitRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *EncryptInitRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EncryptInitRequest.Merge(dst, src)
}
func (m *EncryptInitRequest) XXX_Size() int {
	return m.Size()
}
func (m *EncryptInitRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EncryptInitRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EncryptInitRequest proto.InternalMessageInfo

func (m *EncryptInitRequest) GetMech() *Mechanism {
	if m != nil {
		return m.Mech
	}
	return nil
}

func (m *EncryptInitRequest) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

type EncryptInitResponse struct {
	State                []byte   `protobuf:"bytes,1,opt,name=State,proto3" json:"State,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EncryptInitResponse) Reset()         { *m = EncryptInitResponse{} }
func (m *EncryptInitResponse) String() string { return proto.CompactTextString(m) }
func (*EncryptInitResponse) ProtoMessage()    {}
func (*EncryptInitResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{15}
}
func (m *EncryptInitResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EncryptInitResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EncryptInitResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *EncryptInitResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EncryptInitResponse.Merge(dst, src)
}
func (m *EncryptInitResponse) XXX_Size() int {
	return m.Size()
}
func (m *EncryptInitResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_EncryptInitResponse.DiscardUnknown(m)
}

var xxx_messageInfo_EncryptInitResponse proto.InternalMessageInfo

func (m *EncryptInitResponse) GetState() []byte {
	if m != nil {
		return m.State
	}
	return nil
}

type DecryptInitRequest struct {
	Mech                 *Mechanism `protobuf:"bytes,2,opt,name=Mech" json:"Mech,omitempty"`
	Key                  []byte     `protobuf:"bytes,3,opt,name=Key,proto3" json:"Key,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *DecryptInitRequest) Reset()         { *m = DecryptInitRequest{} }
func (m *DecryptInitRequest) String() string { return proto.CompactTextString(m) }
func (*DecryptInitRequest) ProtoMessage()    {}
func (*DecryptInitRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{16}
}
func (m *DecryptInitRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DecryptInitRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DecryptInitRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DecryptInitRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DecryptInitRequest.Merge(dst, src)
}
func (m *DecryptInitRequest) XXX_Size() int {
	return m.Size()
}
func (m *DecryptInitRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DecryptInitRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DecryptInitRequest proto.InternalMessageInfo

func (m *DecryptInitRequest) GetMech() *Mechanism {
	if m != nil {
		return m.Mech
	}
	return nil
}

func (m *DecryptInitRequest) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

type DecryptInitResponse struct {
	State                []byte   `protobuf:"bytes,1,opt,name=State,proto3" json:"State,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DecryptInitResponse) Reset()         { *m = DecryptInitResponse{} }
func (m *DecryptInitResponse) String() string { return proto.CompactTextString(m) }
func (*DecryptInitResponse) ProtoMessage()    {}
func (*DecryptInitResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{17}
}
func (m *DecryptInitResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DecryptInitResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DecryptInitResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DecryptInitResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DecryptInitResponse.Merge(dst, src)
}
func (m *DecryptInitResponse) XXX_Size() int {
	return m.Size()
}
func (m *DecryptInitResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DecryptInitResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DecryptInitResponse proto.InternalMessageInfo

func (m *DecryptInitResponse) GetState() []byte {
	if m != nil {
		return m.State
	}
	return nil
}

type EncryptUpdateRequest struct {
	State                []byte   `protobuf:"bytes,1,opt,name=State,proto3" json:"State,omitempty"`
	Plain                []byte   `protobuf:"bytes,2,opt,name=Plain,proto3" json:"Plain,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EncryptUpdateRequest) Reset()         { *m = EncryptUpdateRequest{} }
func (m *EncryptUpdateRequest) String() string { return proto.CompactTextString(m) }
func (*EncryptUpdateRequest) ProtoMessage()    {}
func (*EncryptUpdateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{18}
}
func (m *EncryptUpdateRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EncryptUpdateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EncryptUpdateRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *EncryptUpdateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EncryptUpdateRequest.Merge(dst, src)
}
func (m *EncryptUpdateRequest) XXX_Size() int {
	return m.Size()
}
func (m *EncryptUpdateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EncryptUpdateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EncryptUpdateRequest proto.InternalMessageInfo

func (m *EncryptUpdateRequest) GetState() []byte {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *EncryptUpdateRequest) GetPlain() []byte {
	if m != nil {
		return m.Plain
	}
	return nil
}

type EncryptUpdateResponse struct {
	State                []byte   `protobuf:"bytes,1,opt,name=State,proto3" json:"State,omitempty"`
	Ciphered             []byte   `protobuf:"bytes,3,opt,name=Ciphered,proto3" json:"Ciphered,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EncryptUpdateResponse) Reset()         { *m = EncryptUpdateResponse{} }
func (m *EncryptUpdateResponse) String() string { return proto.CompactTextString(m) }
func (*EncryptUpdateResponse) ProtoMessage()    {}
func (*EncryptUpdateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{19}
}
func (m *EncryptUpdateResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EncryptUpdateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EncryptUpdateResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *EncryptUpdateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EncryptUpdateResponse.Merge(dst, src)
}
func (m *EncryptUpdateResponse) XXX_Size() int {
	return m.Size()
}
func (m *EncryptUpdateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_EncryptUpdateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_EncryptUpdateResponse proto.InternalMessageInfo

func (m *EncryptUpdateResponse) GetState() []byte {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *EncryptUpdateResponse) GetCiphered() []byte {
	if m != nil {
		return m.Ciphered
	}
	return nil
}

type DecryptUpdateRequest struct {
	State                []byte   `protobuf:"bytes,1,opt,name=State,proto3" json:"State,omitempty"`
	Ciphered             []byte   `protobuf:"bytes,2,opt,name=Ciphered,proto3" json:"Ciphered,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DecryptUpdateRequest) Reset()         { *m = DecryptUpdateRequest{} }
func (m *DecryptUpdateRequest) String() string { return proto.CompactTextString(m) }
func (*DecryptUpdateRequest) ProtoMessage()    {}
func (*DecryptUpdateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{20}
}
func (m *DecryptUpdateRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DecryptUpdateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DecryptUpdateRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DecryptUpdateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DecryptUpdateRequest.Merge(dst, src)
}
func (m *DecryptUpdateRequest) XXX_Size() int {
	return m.Size()
}
func (m *DecryptUpdateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DecryptUpdateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DecryptUpdateRequest proto.InternalMessageInfo

func (m *DecryptUpdateRequest) GetState() []byte {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *DecryptUpdateRequest) GetCiphered() []byte {
	if m != nil {
		return m.Ciphered
	}
	return nil
}

type DecryptUpdateResponse struct {
	State                []byte   `protobuf:"bytes,1,opt,name=State,proto3" json:"State,omitempty"`
	Plain                []byte   `protobuf:"bytes,3,opt,name=Plain,proto3" json:"Plain,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DecryptUpdateResponse) Reset()         { *m = DecryptUpdateResponse{} }
func (m *DecryptUpdateResponse) String() string { return proto.CompactTextString(m) }
func (*DecryptUpdateResponse) ProtoMessage()    {}
func (*DecryptUpdateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{21}
}
func (m *DecryptUpdateResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DecryptUpdateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DecryptUpdateResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DecryptUpdateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DecryptUpdateResponse.Merge(dst, src)
}
func (m *DecryptUpdateResponse) XXX_Size() int {
	return m.Size()
}
func (m *DecryptUpdateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DecryptUpdateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DecryptUpdateResponse proto.InternalMessageInfo

func (m *DecryptUpdateResponse) GetState() []byte {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *DecryptUpdateResponse) GetPlain() []byte {
	if m != nil {
		return m.Plain
	}
	return nil
}

type EncryptRequest struct {
	State                []byte   `protobuf:"bytes,1,opt,name=State,proto3" json:"State,omitempty"`
	Plain                []byte   `protobuf:"bytes,2,opt,name=Plain,proto3" json:"Plain,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EncryptRequest) Reset()         { *m = EncryptRequest{} }
func (m *EncryptRequest) String() string { return proto.CompactTextString(m) }
func (*EncryptRequest) ProtoMessage()    {}
func (*EncryptRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{22}
}
func (m *EncryptRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EncryptRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EncryptRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *EncryptRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EncryptRequest.Merge(dst, src)
}
func (m *EncryptRequest) XXX_Size() int {
	return m.Size()
}
func (m *EncryptRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EncryptRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EncryptRequest proto.InternalMessageInfo

func (m *EncryptRequest) GetState() []byte {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *EncryptRequest) GetPlain() []byte {
	if m != nil {
		return m.Plain
	}
	return nil
}

type EncryptResponse struct {
	Ciphered             []byte   `protobuf:"bytes,3,opt,name=Ciphered,proto3" json:"Ciphered,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EncryptResponse) Reset()         { *m = EncryptResponse{} }
func (m *EncryptResponse) String() string { return proto.CompactTextString(m) }
func (*EncryptResponse) ProtoMessage()    {}
func (*EncryptResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{23}
}
func (m *EncryptResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EncryptResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EncryptResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *EncryptResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EncryptResponse.Merge(dst, src)
}
func (m *EncryptResponse) XXX_Size() int {
	return m.Size()
}
func (m *EncryptResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_EncryptResponse.DiscardUnknown(m)
}

var xxx_messageInfo_EncryptResponse proto.InternalMessageInfo

func (m *EncryptResponse) GetCiphered() []byte {
	if m != nil {
		return m.Ciphered
	}
	return nil
}

type DecryptRequest struct {
	State                []byte   `protobuf:"bytes,1,opt,name=State,proto3" json:"State,omitempty"`
	Ciphered             []byte   `protobuf:"bytes,2,opt,name=Ciphered,proto3" json:"Ciphered,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DecryptRequest) Reset()         { *m = DecryptRequest{} }
func (m *DecryptRequest) String() string { return proto.CompactTextString(m) }
func (*DecryptRequest) ProtoMessage()    {}
func (*DecryptRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{24}
}
func (m *DecryptRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DecryptRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DecryptRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DecryptRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DecryptRequest.Merge(dst, src)
}
func (m *DecryptRequest) XXX_Size() int {
	return m.Size()
}
func (m *DecryptRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DecryptRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DecryptRequest proto.InternalMessageInfo

func (m *DecryptRequest) GetState() []byte {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *DecryptRequest) GetCiphered() []byte {
	if m != nil {
		return m.Ciphered
	}
	return nil
}

type DecryptResponse struct {
	Plain                []byte   `protobuf:"bytes,3,opt,name=Plain,proto3" json:"Plain,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DecryptResponse) Reset()         { *m = DecryptResponse{} }
func (m *DecryptResponse) String() string { return proto.CompactTextString(m) }
func (*DecryptResponse) ProtoMessage()    {}
func (*DecryptResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{25}
}
func (m *DecryptResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DecryptResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DecryptResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DecryptResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DecryptResponse.Merge(dst, src)
}
func (m *DecryptResponse) XXX_Size() int {
	return m.Size()
}
func (m *DecryptResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DecryptResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DecryptResponse proto.InternalMessageInfo

func (m *DecryptResponse) GetPlain() []byte {
	if m != nil {
		return m.Plain
	}
	return nil
}

type EncryptFinalRequest struct {
	State                []byte   `protobuf:"bytes,1,opt,name=State,proto3" json:"State,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EncryptFinalRequest) Reset()         { *m = EncryptFinalRequest{} }
func (m *EncryptFinalRequest) String() string { return proto.CompactTextString(m) }
func (*EncryptFinalRequest) ProtoMessage()    {}
func (*EncryptFinalRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{26}
}
func (m *EncryptFinalRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EncryptFinalRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EncryptFinalRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *EncryptFinalRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EncryptFinalRequest.Merge(dst, src)
}
func (m *EncryptFinalRequest) XXX_Size() int {
	return m.Size()
}
func (m *EncryptFinalRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EncryptFinalRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EncryptFinalRequest proto.InternalMessageInfo

func (m *EncryptFinalRequest) GetState() []byte {
	if m != nil {
		return m.State
	}
	return nil
}

type EncryptFinalResponse struct {
	Ciphered             []byte   `protobuf:"bytes,2,opt,name=Ciphered,proto3" json:"Ciphered,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EncryptFinalResponse) Reset()         { *m = EncryptFinalResponse{} }
func (m *EncryptFinalResponse) String() string { return proto.CompactTextString(m) }
func (*EncryptFinalResponse) ProtoMessage()    {}
func (*EncryptFinalResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{27}
}
func (m *EncryptFinalResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EncryptFinalResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EncryptFinalResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *EncryptFinalResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EncryptFinalResponse.Merge(dst, src)
}
func (m *EncryptFinalResponse) XXX_Size() int {
	return m.Size()
}
func (m *EncryptFinalResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_EncryptFinalResponse.DiscardUnknown(m)
}

var xxx_messageInfo_EncryptFinalResponse proto.InternalMessageInfo

func (m *EncryptFinalResponse) GetCiphered() []byte {
	if m != nil {
		return m.Ciphered
	}
	return nil
}

type DecryptFinalRequest struct {
	State                []byte   `protobuf:"bytes,1,opt,name=State,proto3" json:"State,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DecryptFinalRequest) Reset()         { *m = DecryptFinalRequest{} }
func (m *DecryptFinalRequest) String() string { return proto.CompactTextString(m) }
func (*DecryptFinalRequest) ProtoMessage()    {}
func (*DecryptFinalRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{28}
}
func (m *DecryptFinalRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DecryptFinalRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DecryptFinalRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DecryptFinalRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DecryptFinalRequest.Merge(dst, src)
}
func (m *DecryptFinalRequest) XXX_Size() int {
	return m.Size()
}
func (m *DecryptFinalRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DecryptFinalRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DecryptFinalRequest proto.InternalMessageInfo

func (m *DecryptFinalRequest) GetState() []byte {
	if m != nil {
		return m.State
	}
	return nil
}

type DecryptFinalResponse struct {
	Plain                []byte   `protobuf:"bytes,2,opt,name=Plain,proto3" json:"Plain,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DecryptFinalResponse) Reset()         { *m = DecryptFinalResponse{} }
func (m *DecryptFinalResponse) String() string { return proto.CompactTextString(m) }
func (*DecryptFinalResponse) ProtoMessage()    {}
func (*DecryptFinalResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{29}
}
func (m *DecryptFinalResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DecryptFinalResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DecryptFinalResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DecryptFinalResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DecryptFinalResponse.Merge(dst, src)
}
func (m *DecryptFinalResponse) XXX_Size() int {
	return m.Size()
}
func (m *DecryptFinalResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DecryptFinalResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DecryptFinalResponse proto.InternalMessageInfo

func (m *DecryptFinalResponse) GetPlain() []byte {
	if m != nil {
		return m.Plain
	}
	return nil
}

type EncryptSingleRequest struct {
	Key                  []byte     `protobuf:"bytes,1,opt,name=Key,proto3" json:"Key,omitempty"`
	Mech                 *Mechanism `protobuf:"bytes,2,opt,name=Mech" json:"Mech,omitempty"`
	Plain                []byte     `protobuf:"bytes,3,opt,name=Plain,proto3" json:"Plain,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *EncryptSingleRequest) Reset()         { *m = EncryptSingleRequest{} }
func (m *EncryptSingleRequest) String() string { return proto.CompactTextString(m) }
func (*EncryptSingleRequest) ProtoMessage()    {}
func (*EncryptSingleRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{30}
}
func (m *EncryptSingleRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EncryptSingleRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EncryptSingleRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *EncryptSingleRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EncryptSingleRequest.Merge(dst, src)
}
func (m *EncryptSingleRequest) XXX_Size() int {
	return m.Size()
}
func (m *EncryptSingleRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EncryptSingleRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EncryptSingleRequest proto.InternalMessageInfo

func (m *EncryptSingleRequest) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *EncryptSingleRequest) GetMech() *Mechanism {
	if m != nil {
		return m.Mech
	}
	return nil
}

func (m *EncryptSingleRequest) GetPlain() []byte {
	if m != nil {
		return m.Plain
	}
	return nil
}

type EncryptSingleResponse struct {
	Ciphered             []byte   `protobuf:"bytes,4,opt,name=Ciphered,proto3" json:"Ciphered,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EncryptSingleResponse) Reset()         { *m = EncryptSingleResponse{} }
func (m *EncryptSingleResponse) String() string { return proto.CompactTextString(m) }
func (*EncryptSingleResponse) ProtoMessage()    {}
func (*EncryptSingleResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{31}
}
func (m *EncryptSingleResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EncryptSingleResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EncryptSingleResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *EncryptSingleResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EncryptSingleResponse.Merge(dst, src)
}
func (m *EncryptSingleResponse) XXX_Size() int {
	return m.Size()
}
func (m *EncryptSingleResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_EncryptSingleResponse.DiscardUnknown(m)
}

var xxx_messageInfo_EncryptSingleResponse proto.InternalMessageInfo

func (m *EncryptSingleResponse) GetCiphered() []byte {
	if m != nil {
		return m.Ciphered
	}
	return nil
}

type DecryptSingleRequest struct {
	Key                  []byte     `protobuf:"bytes,1,opt,name=Key,proto3" json:"Key,omitempty"`
	Mech                 *Mechanism `protobuf:"bytes,2,opt,name=Mech" json:"Mech,omitempty"`
	Ciphered             []byte     `protobuf:"bytes,3,opt,name=Ciphered,proto3" json:"Ciphered,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *DecryptSingleRequest) Reset()         { *m = DecryptSingleRequest{} }
func (m *DecryptSingleRequest) String() string { return proto.CompactTextString(m) }
func (*DecryptSingleRequest) ProtoMessage()    {}
func (*DecryptSingleRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{32}
}
func (m *DecryptSingleRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DecryptSingleRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DecryptSingleRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DecryptSingleRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DecryptSingleRequest.Merge(dst, src)
}
func (m *DecryptSingleRequest) XXX_Size() int {
	return m.Size()
}
func (m *DecryptSingleRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DecryptSingleRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DecryptSingleRequest proto.InternalMessageInfo

func (m *DecryptSingleRequest) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *DecryptSingleRequest) GetMech() *Mechanism {
	if m != nil {
		return m.Mech
	}
	return nil
}

func (m *DecryptSingleRequest) GetCiphered() []byte {
	if m != nil {
		return m.Ciphered
	}
	return nil
}

type DecryptSingleResponse struct {
	Plain                []byte   `protobuf:"bytes,4,opt,name=Plain,proto3" json:"Plain,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DecryptSingleResponse) Reset()         { *m = DecryptSingleResponse{} }
func (m *DecryptSingleResponse) String() string { return proto.CompactTextString(m) }
func (*DecryptSingleResponse) ProtoMessage()    {}
func (*DecryptSingleResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{33}
}
func (m *DecryptSingleResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DecryptSingleResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DecryptSingleResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DecryptSingleResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DecryptSingleResponse.Merge(dst, src)
}
func (m *DecryptSingleResponse) XXX_Size() int {
	return m.Size()
}
func (m *DecryptSingleResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DecryptSingleResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DecryptSingleResponse proto.InternalMessageInfo

func (m *DecryptSingleResponse) GetPlain() []byte {
	if m != nil {
		return m.Plain
	}
	return nil
}

type SignInitRequest struct {
	Mech                 *Mechanism `protobuf:"bytes,2,opt,name=Mech" json:"Mech,omitempty"`
	PrivKey              []byte     `protobuf:"bytes,3,opt,name=PrivKey,proto3" json:"PrivKey,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *SignInitRequest) Reset()         { *m = SignInitRequest{} }
func (m *SignInitRequest) String() string { return proto.CompactTextString(m) }
func (*SignInitRequest) ProtoMessage()    {}
func (*SignInitRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{34}
}
func (m *SignInitRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignInitRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignInitRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SignInitRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignInitRequest.Merge(dst, src)
}
func (m *SignInitRequest) XXX_Size() int {
	return m.Size()
}
func (m *SignInitRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SignInitRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SignInitRequest proto.InternalMessageInfo

func (m *SignInitRequest) GetMech() *Mechanism {
	if m != nil {
		return m.Mech
	}
	return nil
}

func (m *SignInitRequest) GetPrivKey() []byte {
	if m != nil {
		return m.PrivKey
	}
	return nil
}

type SignInitResponse struct {
	State                []byte   `protobuf:"bytes,1,opt,name=State,proto3" json:"State,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SignInitResponse) Reset()         { *m = SignInitResponse{} }
func (m *SignInitResponse) String() string { return proto.CompactTextString(m) }
func (*SignInitResponse) ProtoMessage()    {}
func (*SignInitResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{35}
}
func (m *SignInitResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignInitResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignInitResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SignInitResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignInitResponse.Merge(dst, src)
}
func (m *SignInitResponse) XXX_Size() int {
	return m.Size()
}
func (m *SignInitResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SignInitResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SignInitResponse proto.InternalMessageInfo

func (m *SignInitResponse) GetState() []byte {
	if m != nil {
		return m.State
	}
	return nil
}

type VerifyInitRequest struct {
	Mech                 *Mechanism `protobuf:"bytes,2,opt,name=Mech" json:"Mech,omitempty"`
	PubKey               []byte     `protobuf:"bytes,3,opt,name=PubKey,proto3" json:"PubKey,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *VerifyInitRequest) Reset()         { *m = VerifyInitRequest{} }
func (m *VerifyInitRequest) String() string { return proto.CompactTextString(m) }
func (*VerifyInitRequest) ProtoMessage()    {}
func (*VerifyInitRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{36}
}
func (m *VerifyInitRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VerifyInitRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VerifyInitRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *VerifyInitRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VerifyInitRequest.Merge(dst, src)
}
func (m *VerifyInitRequest) XXX_Size() int {
	return m.Size()
}
func (m *VerifyInitRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_VerifyInitRequest.DiscardUnknown(m)
}

var xxx_messageInfo_VerifyInitRequest proto.InternalMessageInfo

func (m *VerifyInitRequest) GetMech() *Mechanism {
	if m != nil {
		return m.Mech
	}
	return nil
}

func (m *VerifyInitRequest) GetPubKey() []byte {
	if m != nil {
		return m.PubKey
	}
	return nil
}

type VerifyInitResponse struct {
	State                []byte   `protobuf:"bytes,1,opt,name=State,proto3" json:"State,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VerifyInitResponse) Reset()         { *m = VerifyInitResponse{} }
func (m *VerifyInitResponse) String() string { return proto.CompactTextString(m) }
func (*VerifyInitResponse) ProtoMessage()    {}
func (*VerifyInitResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{37}
}
func (m *VerifyInitResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VerifyInitResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VerifyInitResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *VerifyInitResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VerifyInitResponse.Merge(dst, src)
}
func (m *VerifyInitResponse) XXX_Size() int {
	return m.Size()
}
func (m *VerifyInitResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_VerifyInitResponse.DiscardUnknown(m)
}

var xxx_messageInfo_VerifyInitResponse proto.InternalMessageInfo

func (m *VerifyInitResponse) GetState() []byte {
	if m != nil {
		return m.State
	}
	return nil
}

type SignUpdateRequest struct {
	State                []byte   `protobuf:"bytes,1,opt,name=State,proto3" json:"State,omitempty"`
	Data                 []byte   `protobuf:"bytes,2,opt,name=Data,proto3" json:"Data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SignUpdateRequest) Reset()         { *m = SignUpdateRequest{} }
func (m *SignUpdateRequest) String() string { return proto.CompactTextString(m) }
func (*SignUpdateRequest) ProtoMessage()    {}
func (*SignUpdateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{38}
}
func (m *SignUpdateRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignUpdateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignUpdateRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SignUpdateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignUpdateRequest.Merge(dst, src)
}
func (m *SignUpdateRequest) XXX_Size() int {
	return m.Size()
}
func (m *SignUpdateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SignUpdateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SignUpdateRequest proto.InternalMessageInfo

func (m *SignUpdateRequest) GetState() []byte {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *SignUpdateRequest) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type SignUpdateResponse struct {
	State                []byte   `protobuf:"bytes,1,opt,name=State,proto3" json:"State,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SignUpdateResponse) Reset()         { *m = SignUpdateResponse{} }
func (m *SignUpdateResponse) String() string { return proto.CompactTextString(m) }
func (*SignUpdateResponse) ProtoMessage()    {}
func (*SignUpdateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{39}
}
func (m *SignUpdateResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignUpdateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignUpdateResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SignUpdateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignUpdateResponse.Merge(dst, src)
}
func (m *SignUpdateResponse) XXX_Size() int {
	return m.Size()
}
func (m *SignUpdateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SignUpdateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SignUpdateResponse proto.InternalMessageInfo

func (m *SignUpdateResponse) GetState() []byte {
	if m != nil {
		return m.State
	}
	return nil
}

type VerifyUpdateRequest struct {
	State                []byte   `protobuf:"bytes,1,opt,name=State,proto3" json:"State,omitempty"`
	Data                 []byte   `protobuf:"bytes,2,opt,name=Data,proto3" json:"Data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VerifyUpdateRequest) Reset()         { *m = VerifyUpdateRequest{} }
func (m *VerifyUpdateRequest) String() string { return proto.CompactTextString(m) }
func (*VerifyUpdateRequest) ProtoMessage()    {}
func (*VerifyUpdateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{40}
}
func (m *VerifyUpdateRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VerifyUpdateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VerifyUpdateRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *VerifyUpdateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VerifyUpdateRequest.Merge(dst, src)
}
func (m *VerifyUpdateRequest) XXX_Size() int {
	return m.Size()
}
func (m *VerifyUpdateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_VerifyUpdateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_VerifyUpdateRequest proto.InternalMessageInfo

func (m *VerifyUpdateRequest) GetState() []byte {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *VerifyUpdateRequest) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type VerifyUpdateResponse struct {
	State                []byte   `protobuf:"bytes,1,opt,name=State,proto3" json:"State,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VerifyUpdateResponse) Reset()         { *m = VerifyUpdateResponse{} }
func (m *VerifyUpdateResponse) String() string { return proto.CompactTextString(m) }
func (*VerifyUpdateResponse) ProtoMessage()    {}
func (*VerifyUpdateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{41}
}
func (m *VerifyUpdateResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VerifyUpdateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VerifyUpdateResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *VerifyUpdateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VerifyUpdateResponse.Merge(dst, src)
}
func (m *VerifyUpdateResponse) XXX_Size() int {
	return m.Size()
}
func (m *VerifyUpdateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_VerifyUpdateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_VerifyUpdateResponse proto.InternalMessageInfo

func (m *VerifyUpdateResponse) GetState() []byte {
	if m != nil {
		return m.State
	}
	return nil
}

type SignFinalRequest struct {
	State                []byte   `protobuf:"bytes,1,opt,name=State,proto3" json:"State,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SignFinalRequest) Reset()         { *m = SignFinalRequest{} }
func (m *SignFinalRequest) String() string { return proto.CompactTextString(m) }
func (*SignFinalRequest) ProtoMessage()    {}
func (*SignFinalRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{42}
}
func (m *SignFinalRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignFinalRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignFinalRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SignFinalRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignFinalRequest.Merge(dst, src)
}
func (m *SignFinalRequest) XXX_Size() int {
	return m.Size()
}
func (m *SignFinalRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SignFinalRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SignFinalRequest proto.InternalMessageInfo

func (m *SignFinalRequest) GetState() []byte {
	if m != nil {
		return m.State
	}
	return nil
}

type SignFinalResponse struct {
	Signature            []byte   `protobuf:"bytes,2,opt,name=Signature,proto3" json:"Signature,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SignFinalResponse) Reset()         { *m = SignFinalResponse{} }
func (m *SignFinalResponse) String() string { return proto.CompactTextString(m) }
func (*SignFinalResponse) ProtoMessage()    {}
func (*SignFinalResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{43}
}
func (m *SignFinalResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignFinalResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignFinalResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SignFinalResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignFinalResponse.Merge(dst, src)
}
func (m *SignFinalResponse) XXX_Size() int {
	return m.Size()
}
func (m *SignFinalResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SignFinalResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SignFinalResponse proto.InternalMessageInfo

func (m *SignFinalResponse) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

type VerifyFinalRequest struct {
	State                []byte   `protobuf:"bytes,1,opt,name=State,proto3" json:"State,omitempty"`
	Signature            []byte   `protobuf:"bytes,2,opt,name=Signature,proto3" json:"Signature,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VerifyFinalRequest) Reset()         { *m = VerifyFinalRequest{} }
func (m *VerifyFinalRequest) String() string { return proto.CompactTextString(m) }
func (*VerifyFinalRequest) ProtoMessage()    {}
func (*VerifyFinalRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{44}
}
func (m *VerifyFinalRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VerifyFinalRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VerifyFinalRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *VerifyFinalRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VerifyFinalRequest.Merge(dst, src)
}
func (m *VerifyFinalRequest) XXX_Size() int {
	return m.Size()
}
func (m *VerifyFinalRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_VerifyFinalRequest.DiscardUnknown(m)
}

var xxx_messageInfo_VerifyFinalRequest proto.InternalMessageInfo

func (m *VerifyFinalRequest) GetState() []byte {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *VerifyFinalRequest) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

type VerifyFinalResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VerifyFinalResponse) Reset()         { *m = VerifyFinalResponse{} }
func (m *VerifyFinalResponse) String() string { return proto.CompactTextString(m) }
func (*VerifyFinalResponse) ProtoMessage()    {}
func (*VerifyFinalResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{45}
}
func (m *VerifyFinalResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VerifyFinalResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VerifyFinalResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *VerifyFinalResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VerifyFinalResponse.Merge(dst, src)
}
func (m *VerifyFinalResponse) XXX_Size() int {
	return m.Size()
}
func (m *VerifyFinalResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_VerifyFinalResponse.DiscardUnknown(m)
}

var xxx_messageInfo_VerifyFinalResponse proto.InternalMessageInfo

type SignRequest struct {
	State                []byte   `protobuf:"bytes,1,opt,name=State,proto3" json:"State,omitempty"`
	Data                 []byte   `protobuf:"bytes,2,opt,name=Data,proto3" json:"Data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SignRequest) Reset()         { *m = SignRequest{} }
func (m *SignRequest) String() string { return proto.CompactTextString(m) }
func (*SignRequest) ProtoMessage()    {}
func (*SignRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{46}
}
func (m *SignRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SignRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignRequest.Merge(dst, src)
}
func (m *SignRequest) XXX_Size() int {
	return m.Size()
}
func (m *SignRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SignRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SignRequest proto.InternalMessageInfo

func (m *SignRequest) GetState() []byte {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *SignRequest) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type SignResponse struct {
	Signature            []byte   `protobuf:"bytes,3,opt,name=Signature,proto3" json:"Signature,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SignResponse) Reset()         { *m = SignResponse{} }
func (m *SignResponse) String() string { return proto.CompactTextString(m) }
func (*SignResponse) ProtoMessage()    {}
func (*SignResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{47}
}
func (m *SignResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SignResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignResponse.Merge(dst, src)
}
func (m *SignResponse) XXX_Size() int {
	return m.Size()
}
func (m *SignResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SignResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SignResponse proto.InternalMessageInfo

func (m *SignResponse) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

type VerifyRequest struct {
	State                []byte   `protobuf:"bytes,1,opt,name=State,proto3" json:"State,omitempty"`
	Data                 []byte   `protobuf:"bytes,2,opt,name=Data,proto3" json:"Data,omitempty"`
	Signature            []byte   `protobuf:"bytes,3,opt,name=Signature,proto3" json:"Signature,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VerifyRequest) Reset()         { *m = VerifyRequest{} }
func (m *VerifyRequest) String() string { return proto.CompactTextString(m) }
func (*VerifyRequest) ProtoMessage()    {}
func (*VerifyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{48}
}
func (m *VerifyRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VerifyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VerifyRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *VerifyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VerifyRequest.Merge(dst, src)
}
func (m *VerifyRequest) XXX_Size() int {
	return m.Size()
}
func (m *VerifyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_VerifyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_VerifyRequest proto.InternalMessageInfo

func (m *VerifyRequest) GetState() []byte {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *VerifyRequest) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *VerifyRequest) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

type VerifyResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VerifyResponse) Reset()         { *m = VerifyResponse{} }
func (m *VerifyResponse) String() string { return proto.CompactTextString(m) }
func (*VerifyResponse) ProtoMessage()    {}
func (*VerifyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{49}
}
func (m *VerifyResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VerifyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VerifyResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *VerifyResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VerifyResponse.Merge(dst, src)
}
func (m *VerifyResponse) XXX_Size() int {
	return m.Size()
}
func (m *VerifyResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_VerifyResponse.DiscardUnknown(m)
}

var xxx_messageInfo_VerifyResponse proto.InternalMessageInfo

type SignSingleRequest struct {
	PrivKey              []byte     `protobuf:"bytes,1,opt,name=PrivKey,proto3" json:"PrivKey,omitempty"`
	Mech                 *Mechanism `protobuf:"bytes,2,opt,name=Mech" json:"Mech,omitempty"`
	Data                 []byte     `protobuf:"bytes,3,opt,name=Data,proto3" json:"Data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *SignSingleRequest) Reset()         { *m = SignSingleRequest{} }
func (m *SignSingleRequest) String() string { return proto.CompactTextString(m) }
func (*SignSingleRequest) ProtoMessage()    {}
func (*SignSingleRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{50}
}
func (m *SignSingleRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignSingleRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignSingleRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SignSingleRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignSingleRequest.Merge(dst, src)
}
func (m *SignSingleRequest) XXX_Size() int {
	return m.Size()
}
func (m *SignSingleRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SignSingleRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SignSingleRequest proto.InternalMessageInfo

func (m *SignSingleRequest) GetPrivKey() []byte {
	if m != nil {
		return m.PrivKey
	}
	return nil
}

func (m *SignSingleRequest) GetMech() *Mechanism {
	if m != nil {
		return m.Mech
	}
	return nil
}

func (m *SignSingleRequest) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type SignSingleResponse struct {
	Signature            []byte   `protobuf:"bytes,4,opt,name=Signature,proto3" json:"Signature,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SignSingleResponse) Reset()         { *m = SignSingleResponse{} }
func (m *SignSingleResponse) String() string { return proto.CompactTextString(m) }
func (*SignSingleResponse) ProtoMessage()    {}
func (*SignSingleResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{51}
}
func (m *SignSingleResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignSingleResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignSingleResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SignSingleResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignSingleResponse.Merge(dst, src)
}
func (m *SignSingleResponse) XXX_Size() int {
	return m.Size()
}
func (m *SignSingleResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SignSingleResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SignSingleResponse proto.InternalMessageInfo

func (m *SignSingleResponse) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

type VerifySingleRequest struct {
	PubKey               []byte     `protobuf:"bytes,1,opt,name=PubKey,proto3" json:"PubKey,omitempty"`
	Mech                 *Mechanism `protobuf:"bytes,2,opt,name=Mech" json:"Mech,omitempty"`
	Data                 []byte     `protobuf:"bytes,3,opt,name=Data,proto3" json:"Data,omitempty"`
	Signature            []byte     `protobuf:"bytes,4,opt,name=Signature,proto3" json:"Signature,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *VerifySingleRequest) Reset()         { *m = VerifySingleRequest{} }
func (m *VerifySingleRequest) String() string { return proto.CompactTextString(m) }
func (*VerifySingleRequest) ProtoMessage()    {}
func (*VerifySingleRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{52}
}
func (m *VerifySingleRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VerifySingleRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VerifySingleRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *VerifySingleRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VerifySingleRequest.Merge(dst, src)
}
func (m *VerifySingleRequest) XXX_Size() int {
	return m.Size()
}
func (m *VerifySingleRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_VerifySingleRequest.DiscardUnknown(m)
}

var xxx_messageInfo_VerifySingleRequest proto.InternalMessageInfo

func (m *VerifySingleRequest) GetPubKey() []byte {
	if m != nil {
		return m.PubKey
	}
	return nil
}

func (m *VerifySingleRequest) GetMech() *Mechanism {
	if m != nil {
		return m.Mech
	}
	return nil
}

func (m *VerifySingleRequest) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *VerifySingleRequest) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

type VerifySingleResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VerifySingleResponse) Reset()         { *m = VerifySingleResponse{} }
func (m *VerifySingleResponse) String() string { return proto.CompactTextString(m) }
func (*VerifySingleResponse) ProtoMessage()    {}
func (*VerifySingleResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{53}
}
func (m *VerifySingleResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VerifySingleResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VerifySingleResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *VerifySingleResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VerifySingleResponse.Merge(dst, src)
}
func (m *VerifySingleResponse) XXX_Size() int {
	return m.Size()
}
func (m *VerifySingleResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_VerifySingleResponse.DiscardUnknown(m)
}

var xxx_messageInfo_VerifySingleResponse proto.InternalMessageInfo

type GenerateKeyRequest struct {
	Mech                 *Mechanism                                                                             `protobuf:"bytes,1,opt,name=Mech" json:"Mech,omitempty"`
	Template             map[github_com_ibm_developer_ibm_cloud_hyperprotectcrypto_golang_ep11.Attribute][]byte `protobuf:"bytes,2,rep,name=Template,castkey=github.com/ibm-developer/ibm-cloud-hyperprotectcrypto/golang/ep11.Attribute" json:"Template,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	KeyId                string                                                                                 `protobuf:"bytes,4,opt,name=KeyId,proto3" json:"KeyId,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                                                               `json:"-"`
	XXX_unrecognized     []byte                                                                                 `json:"-"`
	XXX_sizecache        int32                                                                                  `json:"-"`
}

func (m *GenerateKeyRequest) Reset()         { *m = GenerateKeyRequest{} }
func (m *GenerateKeyRequest) String() string { return proto.CompactTextString(m) }
func (*GenerateKeyRequest) ProtoMessage()    {}
func (*GenerateKeyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{54}
}
func (m *GenerateKeyRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GenerateKeyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GenerateKeyRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GenerateKeyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenerateKeyRequest.Merge(dst, src)
}
func (m *GenerateKeyRequest) XXX_Size() int {
	return m.Size()
}
func (m *GenerateKeyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GenerateKeyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GenerateKeyRequest proto.InternalMessageInfo

func (m *GenerateKeyRequest) GetMech() *Mechanism {
	if m != nil {
		return m.Mech
	}
	return nil
}

func (m *GenerateKeyRequest) GetTemplate() map[github_com_ibm_developer_ibm_cloud_hyperprotectcrypto_golang_ep11.Attribute][]byte {
	if m != nil {
		return m.Template
	}
	return nil
}

func (m *GenerateKeyRequest) GetKeyId() string {
	if m != nil {
		return m.KeyId
	}
	return ""
}

type GenerateKeyResponse struct {
	Key                  []byte   `protobuf:"bytes,4,opt,name=Key,proto3" json:"Key,omitempty"`
	CheckSum             []byte   `protobuf:"bytes,5,opt,name=CheckSum,proto3" json:"CheckSum,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GenerateKeyResponse) Reset()         { *m = GenerateKeyResponse{} }
func (m *GenerateKeyResponse) String() string { return proto.CompactTextString(m) }
func (*GenerateKeyResponse) ProtoMessage()    {}
func (*GenerateKeyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{55}
}
func (m *GenerateKeyResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GenerateKeyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GenerateKeyResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GenerateKeyResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenerateKeyResponse.Merge(dst, src)
}
func (m *GenerateKeyResponse) XXX_Size() int {
	return m.Size()
}
func (m *GenerateKeyResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GenerateKeyResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GenerateKeyResponse proto.InternalMessageInfo

func (m *GenerateKeyResponse) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *GenerateKeyResponse) GetCheckSum() []byte {
	if m != nil {
		return m.CheckSum
	}
	return nil
}

type GenerateKeyPairRequest struct {
	Mech                 *Mechanism                                                                             `protobuf:"bytes,1,opt,name=Mech" json:"Mech,omitempty"`
	PubKeyTemplate       map[github_com_ibm_developer_ibm_cloud_hyperprotectcrypto_golang_ep11.Attribute][]byte `protobuf:"bytes,2,rep,name=PubKeyTemplate,castkey=github.com/ibm-developer/ibm-cloud-hyperprotectcrypto/golang/ep11.Attribute" json:"PubKeyTemplate,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	PrivKeyTemplate      map[github_com_ibm_developer_ibm_cloud_hyperprotectcrypto_golang_ep11.Attribute][]byte `protobuf:"bytes,3,rep,name=PrivKeyTemplate,castkey=github.com/ibm-developer/ibm-cloud-hyperprotectcrypto/golang/ep11.Attribute" json:"PrivKeyTemplate,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	PrivKeyId            string                                                                                 `protobuf:"bytes,5,opt,name=PrivKeyId,proto3" json:"PrivKeyId,omitempty"`
	PubKeyId             string                                                                                 `protobuf:"bytes,6,opt,name=PubKeyId,proto3" json:"PubKeyId,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                                                               `json:"-"`
	XXX_unrecognized     []byte                                                                                 `json:"-"`
	XXX_sizecache        int32                                                                                  `json:"-"`
}

func (m *GenerateKeyPairRequest) Reset()         { *m = GenerateKeyPairRequest{} }
func (m *GenerateKeyPairRequest) String() string { return proto.CompactTextString(m) }
func (*GenerateKeyPairRequest) ProtoMessage()    {}
func (*GenerateKeyPairRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{56}
}
func (m *GenerateKeyPairRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GenerateKeyPairRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GenerateKeyPairRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GenerateKeyPairRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenerateKeyPairRequest.Merge(dst, src)
}
func (m *GenerateKeyPairRequest) XXX_Size() int {
	return m.Size()
}
func (m *GenerateKeyPairRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GenerateKeyPairRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GenerateKeyPairRequest proto.InternalMessageInfo

func (m *GenerateKeyPairRequest) GetMech() *Mechanism {
	if m != nil {
		return m.Mech
	}
	return nil
}

func (m *GenerateKeyPairRequest) GetPubKeyTemplate() map[github_com_ibm_developer_ibm_cloud_hyperprotectcrypto_golang_ep11.Attribute][]byte {
	if m != nil {
		return m.PubKeyTemplate
	}
	return nil
}

func (m *GenerateKeyPairRequest) GetPrivKeyTemplate() map[github_com_ibm_developer_ibm_cloud_hyperprotectcrypto_golang_ep11.Attribute][]byte {
	if m != nil {
		return m.PrivKeyTemplate
	}
	return nil
}

func (m *GenerateKeyPairRequest) GetPrivKeyId() string {
	if m != nil {
		return m.PrivKeyId
	}
	return ""
}

func (m *GenerateKeyPairRequest) GetPubKeyId() string {
	if m != nil {
		return m.PubKeyId
	}
	return ""
}

type GenerateKeyPairResponse struct {
	PrivKey              []byte   `protobuf:"bytes,5,opt,name=PrivKey,proto3" json:"PrivKey,omitempty"`
	PubKey               []byte   `protobuf:"bytes,6,opt,name=PubKey,proto3" json:"PubKey,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GenerateKeyPairResponse) Reset()         { *m = GenerateKeyPairResponse{} }
func (m *GenerateKeyPairResponse) String() string { return proto.CompactTextString(m) }
func (*GenerateKeyPairResponse) ProtoMessage()    {}
func (*GenerateKeyPairResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{57}
}
func (m *GenerateKeyPairResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GenerateKeyPairResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GenerateKeyPairResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GenerateKeyPairResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenerateKeyPairResponse.Merge(dst, src)
}
func (m *GenerateKeyPairResponse) XXX_Size() int {
	return m.Size()
}
func (m *GenerateKeyPairResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GenerateKeyPairResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GenerateKeyPairResponse proto.InternalMessageInfo

func (m *GenerateKeyPairResponse) GetPrivKey() []byte {
	if m != nil {
		return m.PrivKey
	}
	return nil
}

func (m *GenerateKeyPairResponse) GetPubKey() []byte {
	if m != nil {
		return m.PubKey
	}
	return nil
}

type WrapKeyRequest struct {
	Key                  []byte     `protobuf:"bytes,1,opt,name=Key,proto3" json:"Key,omitempty"`
	KeK                  []byte     `protobuf:"bytes,2,opt,name=KeK,proto3" json:"KeK,omitempty"`
	MacKey               []byte     `protobuf:"bytes,3,opt,name=MacKey,proto3" json:"MacKey,omitempty"`
	Mech                 *Mechanism `protobuf:"bytes,4,opt,name=Mech" json:"Mech,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *WrapKeyRequest) Reset()         { *m = WrapKeyRequest{} }
func (m *WrapKeyRequest) String() string { return proto.CompactTextString(m) }
func (*WrapKeyRequest) ProtoMessage()    {}
func (*WrapKeyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{58}
}
func (m *WrapKeyRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WrapKeyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WrapKeyRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *WrapKeyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WrapKeyRequest.Merge(dst, src)
}
func (m *WrapKeyRequest) XXX_Size() int {
	return m.Size()
}
func (m *WrapKeyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_WrapKeyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_WrapKeyRequest proto.InternalMessageInfo

func (m *WrapKeyRequest) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *WrapKeyRequest) GetKeK() []byte {
	if m != nil {
		return m.KeK
	}
	return nil
}

func (m *WrapKeyRequest) GetMacKey() []byte {
	if m != nil {
		return m.MacKey
	}
	return nil
}

func (m *WrapKeyRequest) GetMech() *Mechanism {
	if m != nil {
		return m.Mech
	}
	return nil
}

type WrapKeyResponse struct {
	Wrapped              []byte   `protobuf:"bytes,5,opt,name=Wrapped,proto3" json:"Wrapped,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WrapKeyResponse) Reset()         { *m = WrapKeyResponse{} }
func (m *WrapKeyResponse) String() string { return proto.CompactTextString(m) }
func (*WrapKeyResponse) ProtoMessage()    {}
func (*WrapKeyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{59}
}
func (m *WrapKeyResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WrapKeyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WrapKeyResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *WrapKeyResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WrapKeyResponse.Merge(dst, src)
}
func (m *WrapKeyResponse) XXX_Size() int {
	return m.Size()
}
func (m *WrapKeyResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_WrapKeyResponse.DiscardUnknown(m)
}

var xxx_messageInfo_WrapKeyResponse proto.InternalMessageInfo

func (m *WrapKeyResponse) GetWrapped() []byte {
	if m != nil {
		return m.Wrapped
	}
	return nil
}

type UnwrapKeyRequest struct {
	Wrapped              []byte                                                                                 `protobuf:"bytes,1,opt,name=Wrapped,proto3" json:"Wrapped,omitempty"`
	KeK                  []byte                                                                                 `protobuf:"bytes,2,opt,name=KeK,proto3" json:"KeK,omitempty"`
	MacKey               []byte                                                                                 `protobuf:"bytes,3,opt,name=MacKey,proto3" json:"MacKey,omitempty"`
	Mech                 *Mechanism                                                                             `protobuf:"bytes,5,opt,name=Mech" json:"Mech,omitempty"`
	Template             map[github_com_ibm_developer_ibm_cloud_hyperprotectcrypto_golang_ep11.Attribute][]byte `protobuf:"bytes,6,rep,name=Template,castkey=github.com/ibm-developer/ibm-cloud-hyperprotectcrypto/golang/ep11.Attribute" json:"Template,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	UnwrappedId          string                                                                                 `protobuf:"bytes,7,opt,name=UnwrappedId,proto3" json:"UnwrappedId,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                                                               `json:"-"`
	XXX_unrecognized     []byte                                                                                 `json:"-"`
	XXX_sizecache        int32                                                                                  `json:"-"`
}

func (m *UnwrapKeyRequest) Reset()         { *m = UnwrapKeyRequest{} }
func (m *UnwrapKeyRequest) String() string { return proto.CompactTextString(m) }
func (*UnwrapKeyRequest) ProtoMessage()    {}
func (*UnwrapKeyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{60}
}
func (m *UnwrapKeyRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnwrapKeyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnwrapKeyRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *UnwrapKeyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnwrapKeyRequest.Merge(dst, src)
}
func (m *UnwrapKeyRequest) XXX_Size() int {
	return m.Size()
}
func (m *UnwrapKeyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UnwrapKeyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UnwrapKeyRequest proto.InternalMessageInfo

func (m *UnwrapKeyRequest) GetWrapped() []byte {
	if m != nil {
		return m.Wrapped
	}
	return nil
}

func (m *UnwrapKeyRequest) GetKeK() []byte {
	if m != nil {
		return m.KeK
	}
	return nil
}

func (m *UnwrapKeyRequest) GetMacKey() []byte {
	if m != nil {
		return m.MacKey
	}
	return nil
}

func (m *UnwrapKeyRequest) GetMech() *Mechanism {
	if m != nil {
		return m.Mech
	}
	return nil
}

func (m *UnwrapKeyRequest) GetTemplate() map[github_com_ibm_developer_ibm_cloud_hyperprotectcrypto_golang_ep11.Attribute][]byte {
	if m != nil {
		return m.Template
	}
	return nil
}

func (m *UnwrapKeyRequest) GetUnwrappedId() string {
	if m != nil {
		return m.UnwrappedId
	}
	return ""
}

type UnwrapKeyResponse struct {
	Unwrapped            []byte   `protobuf:"bytes,7,opt,name=Unwrapped,proto3" json:"Unwrapped,omitempty"`
	CheckSum             []byte   `protobuf:"bytes,8,opt,name=CheckSum,proto3" json:"CheckSum,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UnwrapKeyResponse) Reset()         { *m = UnwrapKeyResponse{} }
func (m *UnwrapKeyResponse) String() string { return proto.CompactTextString(m) }
func (*UnwrapKeyResponse) ProtoMessage()    {}
func (*UnwrapKeyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{61}
}
func (m *UnwrapKeyResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnwrapKeyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnwrapKeyResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *UnwrapKeyResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnwrapKeyResponse.Merge(dst, src)
}
func (m *UnwrapKeyResponse) XXX_Size() int {
	return m.Size()
}
func (m *UnwrapKeyResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UnwrapKeyResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UnwrapKeyResponse proto.InternalMessageInfo

func (m *UnwrapKeyResponse) GetUnwrapped() []byte {
	if m != nil {
		return m.Unwrapped
	}
	return nil
}

func (m *UnwrapKeyResponse) GetCheckSum() []byte {
	if m != nil {
		return m.CheckSum
	}
	return nil
}

type DeriveKeyRequest struct {
	Mech                 *Mechanism                                                                             `protobuf:"bytes,1,opt,name=Mech" json:"Mech,omitempty"`
	Template             map[github_com_ibm_developer_ibm_cloud_hyperprotectcrypto_golang_ep11.Attribute][]byte `protobuf:"bytes,2,rep,name=Template,castkey=github.com/ibm-developer/ibm-cloud-hyperprotectcrypto/golang/ep11.Attribute" json:"Template,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	BaseKey              []byte                                                                                 `protobuf:"bytes,3,opt,name=BaseKey,proto3" json:"BaseKey,omitempty"`
	Data                 []byte                                                                                 `protobuf:"bytes,4,opt,name=Data,proto3" json:"Data,omitempty"`
	NewKeyId             string                                                                                 `protobuf:"bytes,6,opt,name=NewKeyId,proto3" json:"NewKeyId,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                                                               `json:"-"`
	XXX_unrecognized     []byte                                                                                 `json:"-"`
	XXX_sizecache        int32                                                                                  `json:"-"`
}

func (m *DeriveKeyRequest) Reset()         { *m = DeriveKeyRequest{} }
func (m *DeriveKeyRequest) String() string { return proto.CompactTextString(m) }
func (*DeriveKeyRequest) ProtoMessage()    {}
func (*DeriveKeyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{62}
}
func (m *DeriveKeyRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeriveKeyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeriveKeyRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DeriveKeyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeriveKeyRequest.Merge(dst, src)
}
func (m *DeriveKeyRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeriveKeyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeriveKeyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeriveKeyRequest proto.InternalMessageInfo

func (m *DeriveKeyRequest) GetMech() *Mechanism {
	if m != nil {
		return m.Mech
	}
	return nil
}

func (m *DeriveKeyRequest) GetTemplate() map[github_com_ibm_developer_ibm_cloud_hyperprotectcrypto_golang_ep11.Attribute][]byte {
	if m != nil {
		return m.Template
	}
	return nil
}

func (m *DeriveKeyRequest) GetBaseKey() []byte {
	if m != nil {
		return m.BaseKey
	}
	return nil
}

func (m *DeriveKeyRequest) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *DeriveKeyRequest) GetNewKeyId() string {
	if m != nil {
		return m.NewKeyId
	}
	return ""
}

type DeriveKeyResponse struct {
	NewKey               []byte   `protobuf:"bytes,6,opt,name=NewKey,proto3" json:"NewKey,omitempty"`
	CheckSum             []byte   `protobuf:"bytes,7,opt,name=CheckSum,proto3" json:"CheckSum,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeriveKeyResponse) Reset()         { *m = DeriveKeyResponse{} }
func (m *DeriveKeyResponse) String() string { return proto.CompactTextString(m) }
func (*DeriveKeyResponse) ProtoMessage()    {}
func (*DeriveKeyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{63}
}
func (m *DeriveKeyResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeriveKeyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeriveKeyResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DeriveKeyResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeriveKeyResponse.Merge(dst, src)
}
func (m *DeriveKeyResponse) XXX_Size() int {
	return m.Size()
}
func (m *DeriveKeyResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DeriveKeyResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DeriveKeyResponse proto.InternalMessageInfo

func (m *DeriveKeyResponse) GetNewKey() []byte {
	if m != nil {
		return m.NewKey
	}
	return nil
}

func (m *DeriveKeyResponse) GetCheckSum() []byte {
	if m != nil {
		return m.CheckSum
	}
	return nil
}

type GetMechanismListRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetMechanismListRequest) Reset()         { *m = GetMechanismListRequest{} }
func (m *GetMechanismListRequest) String() string { return proto.CompactTextString(m) }
func (*GetMechanismListRequest) ProtoMessage()    {}
func (*GetMechanismListRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{64}
}
func (m *GetMechanismListRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetMechanismListRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetMechanismListRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetMechanismListRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetMechanismListRequest.Merge(dst, src)
}
func (m *GetMechanismListRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetMechanismListRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetMechanismListRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetMechanismListRequest proto.InternalMessageInfo

type GetMechanismListResponse struct {
	Mechs                []github_com_ibm_developer_ibm_cloud_hyperprotectcrypto_golang_ep11.Mechanism `protobuf:"varint,2,rep,packed,name=Mechs,casttype=github.com/ibm-developer/ibm-cloud-hyperprotectcrypto/golang/ep11.Mechanism" json:"Mechs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                                                      `json:"-"`
	XXX_unrecognized     []byte                                                                        `json:"-"`
	XXX_sizecache        int32                                                                         `json:"-"`
}

func (m *GetMechanismListResponse) Reset()         { *m = GetMechanismListResponse{} }
func (m *GetMechanismListResponse) String() string { return proto.CompactTextString(m) }
func (*GetMechanismListResponse) ProtoMessage()    {}
func (*GetMechanismListResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{65}
}
func (m *GetMechanismListResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetMechanismListResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetMechanismListResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetMechanismListResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetMechanismListResponse.Merge(dst, src)
}
func (m *GetMechanismListResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetMechanismListResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetMechanismListResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetMechanismListResponse proto.InternalMessageInfo

func (m *GetMechanismListResponse) GetMechs() []github_com_ibm_developer_ibm_cloud_hyperprotectcrypto_golang_ep11.Mechanism {
	if m != nil {
		return m.Mechs
	}
	return nil
}

type GetMechanismInfoRequest struct {
	Mech                 github_com_ibm_developer_ibm_cloud_hyperprotectcrypto_golang_ep11.Mechanism `protobuf:"varint,2,opt,name=Mech,proto3,casttype=github.com/ibm-developer/ibm-cloud-hyperprotectcrypto/golang/ep11.Mechanism" json:"Mech,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                                                    `json:"-"`
	XXX_unrecognized     []byte                                                                      `json:"-"`
	XXX_sizecache        int32                                                                       `json:"-"`
}

func (m *GetMechanismInfoRequest) Reset()         { *m = GetMechanismInfoRequest{} }
func (m *GetMechanismInfoRequest) String() string { return proto.CompactTextString(m) }
func (*GetMechanismInfoRequest) ProtoMessage()    {}
func (*GetMechanismInfoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{66}
}
func (m *GetMechanismInfoRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetMechanismInfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetMechanismInfoRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetMechanismInfoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetMechanismInfoRequest.Merge(dst, src)
}
func (m *GetMechanismInfoRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetMechanismInfoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetMechanismInfoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetMechanismInfoRequest proto.InternalMessageInfo

func (m *GetMechanismInfoRequest) GetMech() github_com_ibm_developer_ibm_cloud_hyperprotectcrypto_golang_ep11.Mechanism {
	if m != nil {
		return m.Mech
	}
	return 0
}

type GetMechanismInfoResponse struct {
	MechInfo             *MechanismInfo `protobuf:"bytes,3,opt,name=MechInfo" json:"MechInfo,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *GetMechanismInfoResponse) Reset()         { *m = GetMechanismInfoResponse{} }
func (m *GetMechanismInfoResponse) String() string { return proto.CompactTextString(m) }
func (*GetMechanismInfoResponse) ProtoMessage()    {}
func (*GetMechanismInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{67}
}
func (m *GetMechanismInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetMechanismInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetMechanismInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetMechanismInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetMechanismInfoResponse.Merge(dst, src)
}
func (m *GetMechanismInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetMechanismInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetMechanismInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetMechanismInfoResponse proto.InternalMessageInfo

func (m *GetMechanismInfoResponse) GetMechInfo() *MechanismInfo {
	if m != nil {
		return m.MechInfo
	}
	return nil
}

type GetAttributeValueRequest struct {
	Object               []byte                                                                                 `protobuf:"bytes,1,opt,name=Object,proto3" json:"Object,omitempty"`
	Attributes           map[github_com_ibm_developer_ibm_cloud_hyperprotectcrypto_golang_ep11.Attribute][]byte `protobuf:"bytes,2,rep,name=Attributes,castkey=github.com/ibm-developer/ibm-cloud-hyperprotectcrypto/golang/ep11.Attribute" json:"Attributes,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                                                                               `json:"-"`
	XXX_unrecognized     []byte                                                                                 `json:"-"`
	XXX_sizecache        int32                                                                                  `json:"-"`
}

func (m *GetAttributeValueRequest) Reset()         { *m = GetAttributeValueRequest{} }
func (m *GetAttributeValueRequest) String() string { return proto.CompactTextString(m) }
func (*GetAttributeValueRequest) ProtoMessage()    {}
func (*GetAttributeValueRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{68}
}
func (m *GetAttributeValueRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetAttributeValueRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetAttributeValueRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetAttributeValueRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAttributeValueRequest.Merge(dst, src)
}
func (m *GetAttributeValueRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetAttributeValueRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAttributeValueRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetAttributeValueRequest proto.InternalMessageInfo

func (m *GetAttributeValueRequest) GetObject() []byte {
	if m != nil {
		return m.Object
	}
	return nil
}

func (m *GetAttributeValueRequest) GetAttributes() map[github_com_ibm_developer_ibm_cloud_hyperprotectcrypto_golang_ep11.Attribute][]byte {
	if m != nil {
		return m.Attributes
	}
	return nil
}

type GetAttributeValueResponse struct {
	Attributes           map[github_com_ibm_developer_ibm_cloud_hyperprotectcrypto_golang_ep11.Attribute][]byte `protobuf:"bytes,2,rep,name=Attributes,castkey=github.com/ibm-developer/ibm-cloud-hyperprotectcrypto/golang/ep11.Attribute" json:"Attributes,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                                                                               `json:"-"`
	XXX_unrecognized     []byte                                                                                 `json:"-"`
	XXX_sizecache        int32                                                                                  `json:"-"`
}

func (m *GetAttributeValueResponse) Reset()         { *m = GetAttributeValueResponse{} }
func (m *GetAttributeValueResponse) String() string { return proto.CompactTextString(m) }
func (*GetAttributeValueResponse) ProtoMessage()    {}
func (*GetAttributeValueResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{69}
}
func (m *GetAttributeValueResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetAttributeValueResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetAttributeValueResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetAttributeValueResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAttributeValueResponse.Merge(dst, src)
}
func (m *GetAttributeValueResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetAttributeValueResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAttributeValueResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetAttributeValueResponse proto.InternalMessageInfo

func (m *GetAttributeValueResponse) GetAttributes() map[github_com_ibm_developer_ibm_cloud_hyperprotectcrypto_golang_ep11.Attribute][]byte {
	if m != nil {
		return m.Attributes
	}
	return nil
}

type SetAttributeValueRequest struct {
	Object               []byte                                                                                 `protobuf:"bytes,1,opt,name=Object,proto3" json:"Object,omitempty"`
	Attributes           map[github_com_ibm_developer_ibm_cloud_hyperprotectcrypto_golang_ep11.Attribute][]byte `protobuf:"bytes,2,rep,name=Attributes,castkey=github.com/ibm-developer/ibm-cloud-hyperprotectcrypto/golang/ep11.Attribute" json:"Attributes,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                                                                               `json:"-"`
	XXX_unrecognized     []byte                                                                                 `json:"-"`
	XXX_sizecache        int32                                                                                  `json:"-"`
}

func (m *SetAttributeValueRequest) Reset()         { *m = SetAttributeValueRequest{} }
func (m *SetAttributeValueRequest) String() string { return proto.CompactTextString(m) }
func (*SetAttributeValueRequest) ProtoMessage()    {}
func (*SetAttributeValueRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{70}
}
func (m *SetAttributeValueRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetAttributeValueRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetAttributeValueRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SetAttributeValueRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetAttributeValueRequest.Merge(dst, src)
}
func (m *SetAttributeValueRequest) XXX_Size() int {
	return m.Size()
}
func (m *SetAttributeValueRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SetAttributeValueRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SetAttributeValueRequest proto.InternalMessageInfo

func (m *SetAttributeValueRequest) GetObject() []byte {
	if m != nil {
		return m.Object
	}
	return nil
}

func (m *SetAttributeValueRequest) GetAttributes() map[github_com_ibm_developer_ibm_cloud_hyperprotectcrypto_golang_ep11.Attribute][]byte {
	if m != nil {
		return m.Attributes
	}
	return nil
}

type SetAttributeValueResponse struct {
	Object               []byte   `protobuf:"bytes,1,opt,name=Object,proto3" json:"Object,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SetAttributeValueResponse) Reset()         { *m = SetAttributeValueResponse{} }
func (m *SetAttributeValueResponse) String() string { return proto.CompactTextString(m) }
func (*SetAttributeValueResponse) ProtoMessage()    {}
func (*SetAttributeValueResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{71}
}
func (m *SetAttributeValueResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetAttributeValueResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetAttributeValueResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SetAttributeValueResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetAttributeValueResponse.Merge(dst, src)
}
func (m *SetAttributeValueResponse) XXX_Size() int {
	return m.Size()
}
func (m *SetAttributeValueResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SetAttributeValueResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SetAttributeValueResponse proto.InternalMessageInfo

func (m *SetAttributeValueResponse) GetObject() []byte {
	if m != nil {
		return m.Object
	}
	return nil
}

type Mechanism struct {
	Mechanism            github_com_ibm_developer_ibm_cloud_hyperprotectcrypto_golang_ep11.Mechanism `protobuf:"varint,1,opt,name=Mechanism,proto3,casttype=github.com/ibm-developer/ibm-cloud-hyperprotectcrypto/golang/ep11.Mechanism" json:"Mechanism,omitempty"`
	Parameter            []byte                                                                      `protobuf:"bytes,2,opt,name=Parameter,proto3" json:"Parameter,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                                                    `json:"-"`
	XXX_unrecognized     []byte                                                                      `json:"-"`
	XXX_sizecache        int32                                                                       `json:"-"`
}

func (m *Mechanism) Reset()         { *m = Mechanism{} }
func (m *Mechanism) String() string { return proto.CompactTextString(m) }
func (*Mechanism) ProtoMessage()    {}
func (*Mechanism) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{72}
}
func (m *Mechanism) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Mechanism) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Mechanism.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Mechanism) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Mechanism.Merge(dst, src)
}
func (m *Mechanism) XXX_Size() int {
	return m.Size()
}
func (m *Mechanism) XXX_DiscardUnknown() {
	xxx_messageInfo_Mechanism.DiscardUnknown(m)
}

var xxx_messageInfo_Mechanism proto.InternalMessageInfo

func (m *Mechanism) GetMechanism() github_com_ibm_developer_ibm_cloud_hyperprotectcrypto_golang_ep11.Mechanism {
	if m != nil {
		return m.Mechanism
	}
	return 0
}

func (m *Mechanism) GetParameter() []byte {
	if m != nil {
		return m.Parameter
	}
	return nil
}

type MechanismInfo struct {
	MinKeySize           uint64   `protobuf:"varint,1,opt,name=MinKeySize,proto3" json:"MinKeySize,omitempty"`
	MaxKeySize           uint64   `protobuf:"varint,2,opt,name=MaxKeySize,proto3" json:"MaxKeySize,omitempty"`
	Flags                uint64   `protobuf:"varint,3,opt,name=Flags,proto3" json:"Flags,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MechanismInfo) Reset()         { *m = MechanismInfo{} }
func (m *MechanismInfo) String() string { return proto.CompactTextString(m) }
func (*MechanismInfo) ProtoMessage()    {}
func (*MechanismInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{73}
}
func (m *MechanismInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MechanismInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MechanismInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *MechanismInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MechanismInfo.Merge(dst, src)
}
func (m *MechanismInfo) XXX_Size() int {
	return m.Size()
}
func (m *MechanismInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_MechanismInfo.DiscardUnknown(m)
}

var xxx_messageInfo_MechanismInfo proto.InternalMessageInfo

func (m *MechanismInfo) GetMinKeySize() uint64 {
	if m != nil {
		return m.MinKeySize
	}
	return 0
}

func (m *MechanismInfo) GetMaxKeySize() uint64 {
	if m != nil {
		return m.MaxKeySize
	}
	return 0
}

func (m *MechanismInfo) GetFlags() uint64 {
	if m != nil {
		return m.Flags
	}
	return 0
}

type Grep11Error struct {
	Code                 github_com_ibm_developer_ibm_cloud_hyperprotectcrypto_golang_ep11.Return `protobuf:"varint,1,opt,name=Code,proto3,casttype=github.com/ibm-developer/ibm-cloud-hyperprotectcrypto/golang/ep11.Return" json:"Code,omitempty"`
	Detail               string                                                                   `protobuf:"bytes,2,opt,name=Detail,proto3" json:"Detail,omitempty"`
	Retry                bool                                                                     `protobuf:"varint,3,opt,name=Retry,proto3" json:"Retry,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                                                 `json:"-"`
	XXX_unrecognized     []byte                                                                   `json:"-"`
	XXX_sizecache        int32                                                                    `json:"-"`
}

func (m *Grep11Error) Reset()         { *m = Grep11Error{} }
func (m *Grep11Error) String() string { return proto.CompactTextString(m) }
func (*Grep11Error) ProtoMessage()    {}
func (*Grep11Error) Descriptor() ([]byte, []int) {
	return fileDescriptor_server_6ab464f07e1d7a68, []int{74}
}
func (m *Grep11Error) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Grep11Error) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Grep11Error.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Grep11Error) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Grep11Error.Merge(dst, src)
}
func (m *Grep11Error) XXX_Size() int {
	return m.Size()
}
func (m *Grep11Error) XXX_DiscardUnknown() {
	xxx_messageInfo_Grep11Error.DiscardUnknown(m)
}

var xxx_messageInfo_Grep11Error proto.InternalMessageInfo

func (m *Grep11Error) GetCode() github_com_ibm_developer_ibm_cloud_hyperprotectcrypto_golang_ep11.Return {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *Grep11Error) GetDetail() string {
	if m != nil {
		return m.Detail
	}
	return ""
}

func (m *Grep11Error) GetRetry() bool {
	if m != nil {
		return m.Retry
	}
	return false
}

func init() {
	proto.RegisterType((*GenerateRandomRequest)(nil), "grep11.GenerateRandomRequest")
	proto.RegisterType((*GenerateRandomResponse)(nil), "grep11.GenerateRandomResponse")
	proto.RegisterType((*DigestInitRequest)(nil), "grep11.DigestInitRequest")
	proto.RegisterType((*DigestInitResponse)(nil), "grep11.DigestInitResponse")
	proto.RegisterType((*DigestRequest)(nil), "grep11.DigestRequest")
	proto.RegisterType((*DigestResponse)(nil), "grep11.DigestResponse")
	proto.RegisterType((*DigestUpdateRequest)(nil), "grep11.DigestUpdateRequest")
	proto.RegisterType((*DigestUpdateResponse)(nil), "grep11.DigestUpdateResponse")
	proto.RegisterType((*DigestKeyRequest)(nil), "grep11.DigestKeyRequest")
	proto.RegisterType((*DigestKeyResponse)(nil), "grep11.DigestKeyResponse")
	proto.RegisterType((*DigestFinalRequest)(nil), "grep11.DigestFinalRequest")
	proto.RegisterType((*DigestFinalResponse)(nil), "grep11.DigestFinalResponse")
	proto.RegisterType((*DigestSingleRequest)(nil), "grep11.DigestSingleRequest")
	proto.RegisterType((*DigestSingleResponse)(nil), "grep11.DigestSingleResponse")
	proto.RegisterType((*EncryptInitRequest)(nil), "grep11.EncryptInitRequest")
	proto.RegisterType((*EncryptInitResponse)(nil), "grep11.EncryptInitResponse")
	proto.RegisterType((*DecryptInitRequest)(nil), "grep11.DecryptInitRequest")
	proto.RegisterType((*DecryptInitResponse)(nil), "grep11.DecryptInitResponse")
	proto.RegisterType((*EncryptUpdateRequest)(nil), "grep11.EncryptUpdateRequest")
	proto.RegisterType((*EncryptUpdateResponse)(nil), "grep11.EncryptUpdateResponse")
	proto.RegisterType((*DecryptUpdateRequest)(nil), "grep11.DecryptUpdateRequest")
	proto.RegisterType((*DecryptUpdateResponse)(nil), "grep11.DecryptUpdateResponse")
	proto.RegisterType((*EncryptRequest)(nil), "grep11.EncryptRequest")
	proto.RegisterType((*EncryptResponse)(nil), "grep11.EncryptResponse")
	proto.RegisterType((*DecryptRequest)(nil), "grep11.DecryptRequest")
	proto.RegisterType((*DecryptResponse)(nil), "grep11.DecryptResponse")
	proto.RegisterType((*EncryptFinalRequest)(nil), "grep11.EncryptFinalRequest")
	proto.RegisterType((*EncryptFinalResponse)(nil), "grep11.EncryptFinalResponse")
	proto.RegisterType((*DecryptFinalRequest)(nil), "grep11.DecryptFinalRequest")
	proto.RegisterType((*DecryptFinalResponse)(nil), "grep11.DecryptFinalResponse")
	proto.RegisterType((*EncryptSingleRequest)(nil), "grep11.EncryptSingleRequest")
	proto.RegisterType((*EncryptSingleResponse)(nil), "grep11.EncryptSingleResponse")
	proto.RegisterType((*DecryptSingleRequest)(nil), "grep11.DecryptSingleRequest")
	proto.RegisterType((*DecryptSingleResponse)(nil), "grep11.DecryptSingleResponse")
	proto.RegisterType((*SignInitRequest)(nil), "grep11.SignInitRequest")
	proto.RegisterType((*SignInitResponse)(nil), "grep11.SignInitResponse")
	proto.RegisterType((*VerifyInitRequest)(nil), "grep11.VerifyInitRequest")
	proto.RegisterType((*VerifyInitResponse)(nil), "grep11.VerifyInitResponse")
	proto.RegisterType((*SignUpdateRequest)(nil), "grep11.SignUpdateRequest")
	proto.RegisterType((*SignUpdateResponse)(nil), "grep11.SignUpdateResponse")
	proto.RegisterType((*VerifyUpdateRequest)(nil), "grep11.VerifyUpdateRequest")
	proto.RegisterType((*VerifyUpdateResponse)(nil), "grep11.VerifyUpdateResponse")
	proto.RegisterType((*SignFinalRequest)(nil), "grep11.SignFinalRequest")
	proto.RegisterType((*SignFinalResponse)(nil), "grep11.SignFinalResponse")
	proto.RegisterType((*VerifyFinalRequest)(nil), "grep11.VerifyFinalRequest")
	proto.RegisterType((*VerifyFinalResponse)(nil), "grep11.VerifyFinalResponse")
	proto.RegisterType((*SignRequest)(nil), "grep11.SignRequest")
	proto.RegisterType((*SignResponse)(nil), "grep11.SignResponse")
	proto.RegisterType((*VerifyRequest)(nil), "grep11.VerifyRequest")
	proto.RegisterType((*VerifyResponse)(nil), "grep11.VerifyResponse")
	proto.RegisterType((*SignSingleRequest)(nil), "grep11.SignSingleRequest")
	proto.RegisterType((*SignSingleResponse)(nil), "grep11.SignSingleResponse")
	proto.RegisterType((*VerifySingleRequest)(nil), "grep11.VerifySingleRequest")
	proto.RegisterType((*VerifySingleResponse)(nil), "grep11.VerifySingleResponse")
	proto.RegisterType((*GenerateKeyRequest)(nil), "grep11.GenerateKeyRequest")
	proto.RegisterMapType((map[github_com_ibm_developer_ibm_cloud_hyperprotectcrypto_golang_ep11.Attribute][]byte)(nil), "grep11.GenerateKeyRequest.TemplateEntry")
	proto.RegisterType((*GenerateKeyResponse)(nil), "grep11.GenerateKeyResponse")
	proto.RegisterType((*GenerateKeyPairRequest)(nil), "grep11.GenerateKeyPairRequest")
	proto.RegisterMapType((map[github_com_ibm_developer_ibm_cloud_hyperprotectcrypto_golang_ep11.Attribute][]byte)(nil), "grep11.GenerateKeyPairRequest.PrivKeyTemplateEntry")
	proto.RegisterMapType((map[github_com_ibm_developer_ibm_cloud_hyperprotectcrypto_golang_ep11.Attribute][]byte)(nil), "grep11.GenerateKeyPairRequest.PubKeyTemplateEntry")
	proto.RegisterType((*GenerateKeyPairResponse)(nil), "grep11.GenerateKeyPairResponse")
	proto.RegisterType((*WrapKeyRequest)(nil), "grep11.WrapKeyRequest")
	proto.RegisterType((*WrapKeyResponse)(nil), "grep11.WrapKeyResponse")
	proto.RegisterType((*UnwrapKeyRequest)(nil), "grep11.UnwrapKeyRequest")
	proto.RegisterMapType((map[github_com_ibm_developer_ibm_cloud_hyperprotectcrypto_golang_ep11.Attribute][]byte)(nil), "grep11.UnwrapKeyRequest.TemplateEntry")
	proto.RegisterType((*UnwrapKeyResponse)(nil), "grep11.UnwrapKeyResponse")
	proto.RegisterType((*DeriveKeyRequest)(nil), "grep11.DeriveKeyRequest")
	proto.RegisterMapType((map[github_com_ibm_developer_ibm_cloud_hyperprotectcrypto_golang_ep11.Attribute][]byte)(nil), "grep11.DeriveKeyRequest.TemplateEntry")
	proto.RegisterType((*DeriveKeyResponse)(nil), "grep11.DeriveKeyResponse")
	proto.RegisterType((*GetMechanismListRequest)(nil), "grep11.GetMechanismListRequest")
	proto.RegisterType((*GetMechanismListResponse)(nil), "grep11.GetMechanismListResponse")
	proto.RegisterType((*GetMechanismInfoRequest)(nil), "grep11.GetMechanismInfoRequest")
	proto.RegisterType((*GetMechanismInfoResponse)(nil), "grep11.GetMechanismInfoResponse")
	proto.RegisterType((*GetAttributeValueRequest)(nil), "grep11.GetAttributeValueRequest")
	proto.RegisterMapType((map[github_com_ibm_developer_ibm_cloud_hyperprotectcrypto_golang_ep11.Attribute][]byte)(nil), "grep11.GetAttributeValueRequest.AttributesEntry")
	proto.RegisterType((*GetAttributeValueResponse)(nil), "grep11.GetAttributeValueResponse")
	proto.RegisterMapType((map[github_com_ibm_developer_ibm_cloud_hyperprotectcrypto_golang_ep11.Attribute][]byte)(nil), "grep11.GetAttributeValueResponse.AttributesEntry")
	proto.RegisterType((*SetAttributeValueRequest)(nil), "grep11.SetAttributeValueRequest")
	proto.RegisterMapType((map[github_com_ibm_developer_ibm_cloud_hyperprotectcrypto_golang_ep11.Attribute][]byte)(nil), "grep11.SetAttributeValueRequest.AttributesEntry")
	proto.RegisterType((*SetAttributeValueResponse)(nil), "grep11.SetAttributeValueResponse")
	proto.RegisterType((*Mechanism)(nil), "grep11.Mechanism")
	proto.RegisterType((*MechanismInfo)(nil), "grep11.MechanismInfo")
	proto.RegisterType((*Grep11Error)(nil), "grep11.Grep11Error")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Crypto service

type CryptoClient interface {
	// See https://www-03.ibm.com/security/cryptocards/pciecc/pdf/ep11-structure.pdf for
	// further documentation
	// CK_RV m_GenerateRandom (
	//     CK_BYTE_PTR rnd, CK_ULONG rndlen,
	//     target_t target) ;
	GenerateRandom(ctx context.Context, in *GenerateRandomRequest, opts ...grpc.CallOption) (*GenerateRandomResponse, error)
	// CK_RV m_DigestInit (
	//     unsigned char *state, size_t *statelen,
	//     const CK_MECHANISM_PTR mech,
	//     target_t target) ;
	DigestInit(ctx context.Context, in *DigestInitRequest, opts ...grpc.CallOption) (*DigestInitResponse, error)
	// CK_RV m_Digest (
	//     const unsigned char *state, size_t statelen,
	//     CK_BYTE_PTR data, CK_ULONG datalen,
	//     CK_BYTE_PTR digest, CK_ULONG_PTR digestlen,
	//     target_t target) ;
	Digest(ctx context.Context, in *DigestRequest, opts ...grpc.CallOption) (*DigestResponse, error)
	// CK_RV m_DigestUpdate (
	//     unsigned char *state, size_t statelen,
	//     CK_BYTE_PTR data, CK_ULONG datalen,
	//     target_t target) ;
	DigestUpdate(ctx context.Context, in *DigestUpdateRequest, opts ...grpc.CallOption) (*DigestUpdateResponse, error)
	// CK_RV m_DigestKey (
	//     unsigned char *state, size_t statelen,
	//     const unsigned char *key, size_t keylen,
	//     target_t target) ;
	DigestKey(ctx context.Context, in *DigestKeyRequest, opts ...grpc.CallOption) (*DigestKeyResponse, error)
	// CK_RV m_DigestFinal (
	//     const unsigned char *state, size_t statelen,
	//     CK_BYTE_PTR digest, CK_ULONG_PTR digestlen,
	//     target_t target) ;
	DigestFinal(ctx context.Context, in *DigestFinalRequest, opts ...grpc.CallOption) (*DigestFinalResponse, error)
	// CK_RV m_DigestSingle (
	//     CK_MECHANISM_PTR mech,
	//     CK_BYTE_PTR data, CK_ULONG datalen,
	//     CK_BYTE_PTR digest, CK_ULONG_PTR digestlen,
	//     target_t target) ;
	DigestSingle(ctx context.Context, in *DigestSingleRequest, opts ...grpc.CallOption) (*DigestSingleResponse, error)
	// CK_RV m_EncryptInit (
	//     unsigned char *state, size_t *statelen,
	//     CK_MECHANISM_PTR mech,
	//     const unsigned char *key, size_t keylen,
	//     target_t target) ;
	EncryptInit(ctx context.Context, in *EncryptInitRequest, opts ...grpc.CallOption) (*EncryptInitResponse, error)
	// CK_RV m_DecryptInit (
	//     unsigned char *state, size_t *statelen,
	//     CK_MECHANISM_PTR mech,
	//     const unsigned char *key, size_t keylen,
	//     target_t target) ;
	DecryptInit(ctx context.Context, in *DecryptInitRequest, opts ...grpc.CallOption) (*DecryptInitResponse, error)
	// CK_RV m_EncryptUpdate (
	//     unsigned char *state, size_t statelen,
	//     CK_BYTE_PTR plain, CK_ULONG plainlen,
	//     CK_BYTE_PTR ciphered, CK_ULONG_PTR cipheredlen,
	//     target_t target) ;
	EncryptUpdate(ctx context.Context, in *EncryptUpdateRequest, opts ...grpc.CallOption) (*EncryptUpdateResponse, error)
	// CK_RV m_DecryptUpdate (
	//     unsigned char *state, size_t statelen,
	//     CK_BYTE_PTR ciphered, CK_ULONG cipheredlen,
	//     CK_BYTE_PTR plain, CK_ULONG_PTR plainlen,
	//     target_t target) ;
	DecryptUpdate(ctx context.Context, in *DecryptUpdateRequest, opts ...grpc.CallOption) (*DecryptUpdateResponse, error)
	// CK_RV m_Encrypt (
	//     const unsigned char *state, size_t statelen,
	//     CK_BYTE_PTR plain, CK_ULONG plainlen,
	//     CK_BYTE_PTR ciphered, CK_ULONG_PTR cipheredlen,
	//     target_t target) ;
	Encrypt(ctx context.Context, in *EncryptRequest, opts ...grpc.CallOption) (*EncryptResponse, error)
	// CK_RV m_Decrypt (
	//     const unsigned char *state, size_t statelen,
	//     CK_BYTE_PTR ciphered, CK_ULONG cipheredlen,
	//     CK_BYTE_PTR plain, CK_ULONG_PTR plainlen,
	//     target_t target) ;
	Decrypt(ctx context.Context, in *DecryptRequest, opts ...grpc.CallOption) (*DecryptResponse, error)
	// CK_RV m_EncryptFinal (
	//     const unsigned char *state, size_t statelen,
	//     CK_BYTE_PTR ciphered, CK_ULONG_PTR cipheredlen,
	//     target_t target) ;
	EncryptFinal(ctx context.Context, in *EncryptFinalRequest, opts ...grpc.CallOption) (*EncryptFinalResponse, error)
	// CK_RV m_DecryptFinal (
	//     const unsigned char *state, size_t statelen,
	//     CK_BYTE_PTR plain, CK_ULONG_PTR plainlen,
	//     target_t target) ;
	DecryptFinal(ctx context.Context, in *DecryptFinalRequest, opts ...grpc.CallOption) (*DecryptFinalResponse, error)
	// CK_RV m_EncryptSingle (
	//     const unsigned char *key, size_t keylen,
	//     CK_MECHANISM_PTR mech,
	//     CK_BYTE_PTR plain, CK_ULONG plainlen,
	//     CK_BYTE_PTR ciphered, CK_ULONG_PTR cipheredlen,
	//     target_t target) ;
	EncryptSingle(ctx context.Context, in *EncryptSingleRequest, opts ...grpc.CallOption) (*EncryptSingleResponse, error)
	// CK_RV m_DecryptSingle (
	//     const unsigned char *key, size_t keylen,
	//     CK_MECHANISM_PTR mech,
	//     CK_BYTE_PTR ciphered, CK_ULONG cipheredlen,
	//     CK_BYTE_PTR plain, CK_ULONG_PTR plainlen,
	//     target_t target) ;
	DecryptSingle(ctx context.Context, in *DecryptSingleRequest, opts ...grpc.CallOption) (*DecryptSingleResponse, error)
	// CK_RV m_SignInit (
	//     unsigned char *state, size_t *statelen,
	//     CK_MECHANISM_PTR mech,
	//     const unsigned char *privKey, size_t privKeylen,
	//     target_t target) ;
	SignInit(ctx context.Context, in *SignInitRequest, opts ...grpc.CallOption) (*SignInitResponse, error)
	// CK_RV m_VerifyInit (
	//     unsigned char *state, size_t *statelen,
	//     CK_MECHANISM_PTR mech,
	//     const unsigned char *pubKey, size_t pubKeylen,
	//     target_t target) ;
	VerifyInit(ctx context.Context, in *VerifyInitRequest, opts ...grpc.CallOption) (*VerifyInitResponse, error)
	// CK_RV m_SignUpdate (
	//     unsigned char *state, size_t statelen,
	//     CK_BYTE_PTR data, CK_ULONG datalen,
	//     target_t target) ;
	SignUpdate(ctx context.Context, in *SignUpdateRequest, opts ...grpc.CallOption) (*SignUpdateResponse, error)
	// CK_RV m_VerifyUpdate (
	//     unsigned char *state, size_t statelen,
	//     CK_BYTE_PTR data, CK_ULONG datalen,
	//     target_t target) ;
	VerifyUpdate(ctx context.Context, in *VerifyUpdateRequest, opts ...grpc.CallOption) (*VerifyUpdateResponse, error)
	// CK_RV m_SignFinal (
	//     const unsigned char *state, size_t statelen,
	//     CK_BYTE_PTR signature, CK_ULONG_PTR signaturelen,
	//     target_t target) ;
	SignFinal(ctx context.Context, in *SignFinalRequest, opts ...grpc.CallOption) (*SignFinalResponse, error)
	// CK_RV m_VerifyFinal (
	//     const unsigned char *state, size_t statelen,
	//     CK_BYTE_PTR signature, CK_ULONG signaturelen,
	//     target_t target) ;
	VerifyFinal(ctx context.Context, in *VerifyFinalRequest, opts ...grpc.CallOption) (*VerifyFinalResponse, error)
	// CK_RV m_Sign (
	//     const unsigned char *state, size_t statelen,
	//     CK_BYTE_PTR data, CK_ULONG datalen,
	//     CK_BYTE_PTR signature, CK_ULONG_PTR signaturelen,
	//     target_t target) ;
	Sign(ctx context.Context, in *SignRequest, opts ...grpc.CallOption) (*SignResponse, error)
	// CK_RV m_Verify (
	//     const unsigned char *state, size_t statelen,
	//     CK_BYTE_PTR data, CK_ULONG datalen,
	//     CK_BYTE_PTR signature, CK_ULONG signaturelen,
	//     target_t target) ;
	Verify(ctx context.Context, in *VerifyRequest, opts ...grpc.CallOption) (*VerifyResponse, error)
	// CK_RV m_SignSingle (
	//     const unsigned char *privKey, size_t privKeylen,
	//     CK_MECHANISM_PTR mech,
	//     CK_BYTE_PTR data, CK_ULONG datalen,
	//     CK_BYTE_PTR signature, CK_ULONG_PTR signaturelen,
	//     target_t target) ;
	SignSingle(ctx context.Context, in *SignSingleRequest, opts ...grpc.CallOption) (*SignSingleResponse, error)
	// CK_RV m_VerifySingle (
	//     const unsigned char *pubKey, size_t pubKeylen,
	//     CK_MECHANISM_PTR mech,
	//     CK_BYTE_PTR data, CK_ULONG datalen,
	//     CK_BYTE_PTR signature, CK_ULONG signaturelen,
	//     target_t target) ;
	VerifySingle(ctx context.Context, in *VerifySingleRequest, opts ...grpc.CallOption) (*VerifySingleResponse, error)
	// CK_RV m_GenerateKey (
	//     CK_MECHANISM_PTR mech,
	//     CK_ATTRIBUTE_PTR template, CK_ULONG templatelen,
	//     const unsigned char *pin, size_t pinlen,
	//     unsigned char *key, size_t *keylen,
	//     unsigned char *checkSum, size_t *checkSumlen,
	//     target_t target) ;
	GenerateKey(ctx context.Context, in *GenerateKeyRequest, opts ...grpc.CallOption) (*GenerateKeyResponse, error)
	// CK_RV m_GenerateKeyPair (
	//     CK_MECHANISM_PTR mech,
	//     CK_ATTRIBUTE_PTR pubKeyTemplate, CK_ULONG pubKeyTemplatelen,
	//     CK_ATTRIBUTE_PTR privKeyTemplate, CK_ULONG privKeyTemplatelen,
	//     const unsigned char *pin, size_t pinlen,
	//     unsigned char *privKey, size_t *privKeylen,
	//     unsigned char *pubKey, size_t *pubKeylen,
	//     target_t target) ;
	GenerateKeyPair(ctx context.Context, in *GenerateKeyPairRequest, opts ...grpc.CallOption) (*GenerateKeyPairResponse, error)
	// CK_RV m_WrapKey (
	//     const unsigned char *key, size_t keylen,
	//     const unsigned char *keK, size_t keKlen,
	//     const unsigned char *macKey, size_t macKeylen,
	//     const CK_MECHANISM_PTR mech,
	//     CK_BYTE_PTR wrapped, CK_ULONG_PTR wrappedlen,
	//     target_t target) ;
	WrapKey(ctx context.Context, in *WrapKeyRequest, opts ...grpc.CallOption) (*WrapKeyResponse, error)
	// CK_RV m_UnwrapKey (
	//     const CK_BYTE_PTR wrapped, CK_ULONG wrappedlen,
	//     const unsigned char *keK, size_t keKlen,
	//     const unsigned char *macKey, size_t macKeylen,
	//     const unsigned char *pin, size_t pinlen,
	//     const CK_MECHANISM_PTR mech,
	//     const CK_ATTRIBUTE_PTR template, CK_ULONG templatelen,
	//     unsigned char *unwrapped, size_t *unwrappedlen,
	//     CK_BYTE_PTR checkSum, CK_ULONG *checkSumlen,
	//     target_t target) ;
	UnwrapKey(ctx context.Context, in *UnwrapKeyRequest, opts ...grpc.CallOption) (*UnwrapKeyResponse, error)
	// CK_RV m_DeriveKey (
	//     CK_MECHANISM_PTR mech,
	//     CK_ATTRIBUTE_PTR template, CK_ULONG templatelen,
	//     const unsigned char *baseKey, size_t baseKeylen,
	//     const unsigned char *data, size_t datalen,
	//     const unsigned char *pin, size_t pinlen,
	//     unsigned char *newKey, size_t *newKeylen,
	//     unsigned char *checkSum, size_t *checkSumlen,
	//     target_t target) ;
	DeriveKey(ctx context.Context, in *DeriveKeyRequest, opts ...grpc.CallOption) (*DeriveKeyResponse, error)
	// CK_RV m_GetMechanismList (
	//     CK_SLOT_ID slot,
	//     CK_MECHANISM_TYPE_PTR mechs, CK_ULONG_PTR mechslen,
	//     target_t target) ;
	GetMechanismList(ctx context.Context, in *GetMechanismListRequest, opts ...grpc.CallOption) (*GetMechanismListResponse, error)
	// CK_RV m_GetMechanismInfo (
	//     CK_SLOT_ID slot,
	//     CK_MECHANISM_TYPE mech,
	//     CK_MECHANISM_INFO_PTR mechInfo,
	//     target_t target) ;
	GetMechanismInfo(ctx context.Context, in *GetMechanismInfoRequest, opts ...grpc.CallOption) (*GetMechanismInfoResponse, error)
	// CK_RV m_GetAttributeValue (
	//     const unsigned char *object, size_t objectlen,
	//     CK_ATTRIBUTE_PTR attributes, CK_ULONG attributeslen,
	//     target_t target) ;
	GetAttributeValue(ctx context.Context, in *GetAttributeValueRequest, opts ...grpc.CallOption) (*GetAttributeValueResponse, error)
	// CK_RV m_SetAttributeValue (
	//     unsigned char *object, size_t objectlen,
	//     CK_ATTRIBUTE_PTR attributes, CK_ULONG attributeslen,
	//     target_t target) ;
	SetAttributeValue(ctx context.Context, in *SetAttributeValueRequest, opts ...grpc.CallOption) (*SetAttributeValueResponse, error)
}

type cryptoClient struct {
	cc *grpc.ClientConn
}

func NewCryptoClient(cc *grpc.ClientConn) CryptoClient {
	return &cryptoClient{cc}
}

func (c *cryptoClient) GenerateRandom(ctx context.Context, in *GenerateRandomRequest, opts ...grpc.CallOption) (*GenerateRandomResponse, error) {
	out := new(GenerateRandomResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/GenerateRandom", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) DigestInit(ctx context.Context, in *DigestInitRequest, opts ...grpc.CallOption) (*DigestInitResponse, error) {
	out := new(DigestInitResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/DigestInit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) Digest(ctx context.Context, in *DigestRequest, opts ...grpc.CallOption) (*DigestResponse, error) {
	out := new(DigestResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/Digest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) DigestUpdate(ctx context.Context, in *DigestUpdateRequest, opts ...grpc.CallOption) (*DigestUpdateResponse, error) {
	out := new(DigestUpdateResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/DigestUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) DigestKey(ctx context.Context, in *DigestKeyRequest, opts ...grpc.CallOption) (*DigestKeyResponse, error) {
	out := new(DigestKeyResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/DigestKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) DigestFinal(ctx context.Context, in *DigestFinalRequest, opts ...grpc.CallOption) (*DigestFinalResponse, error) {
	out := new(DigestFinalResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/DigestFinal", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) DigestSingle(ctx context.Context, in *DigestSingleRequest, opts ...grpc.CallOption) (*DigestSingleResponse, error) {
	out := new(DigestSingleResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/DigestSingle", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) EncryptInit(ctx context.Context, in *EncryptInitRequest, opts ...grpc.CallOption) (*EncryptInitResponse, error) {
	out := new(EncryptInitResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/EncryptInit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) DecryptInit(ctx context.Context, in *DecryptInitRequest, opts ...grpc.CallOption) (*DecryptInitResponse, error) {
	out := new(DecryptInitResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/DecryptInit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) EncryptUpdate(ctx context.Context, in *EncryptUpdateRequest, opts ...grpc.CallOption) (*EncryptUpdateResponse, error) {
	out := new(EncryptUpdateResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/EncryptUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) DecryptUpdate(ctx context.Context, in *DecryptUpdateRequest, opts ...grpc.CallOption) (*DecryptUpdateResponse, error) {
	out := new(DecryptUpdateResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/DecryptUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) Encrypt(ctx context.Context, in *EncryptRequest, opts ...grpc.CallOption) (*EncryptResponse, error) {
	out := new(EncryptResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/Encrypt", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) Decrypt(ctx context.Context, in *DecryptRequest, opts ...grpc.CallOption) (*DecryptResponse, error) {
	out := new(DecryptResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/Decrypt", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) EncryptFinal(ctx context.Context, in *EncryptFinalRequest, opts ...grpc.CallOption) (*EncryptFinalResponse, error) {
	out := new(EncryptFinalResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/EncryptFinal", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) DecryptFinal(ctx context.Context, in *DecryptFinalRequest, opts ...grpc.CallOption) (*DecryptFinalResponse, error) {
	out := new(DecryptFinalResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/DecryptFinal", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) EncryptSingle(ctx context.Context, in *EncryptSingleRequest, opts ...grpc.CallOption) (*EncryptSingleResponse, error) {
	out := new(EncryptSingleResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/EncryptSingle", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) DecryptSingle(ctx context.Context, in *DecryptSingleRequest, opts ...grpc.CallOption) (*DecryptSingleResponse, error) {
	out := new(DecryptSingleResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/DecryptSingle", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) SignInit(ctx context.Context, in *SignInitRequest, opts ...grpc.CallOption) (*SignInitResponse, error) {
	out := new(SignInitResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/SignInit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) VerifyInit(ctx context.Context, in *VerifyInitRequest, opts ...grpc.CallOption) (*VerifyInitResponse, error) {
	out := new(VerifyInitResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/VerifyInit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) SignUpdate(ctx context.Context, in *SignUpdateRequest, opts ...grpc.CallOption) (*SignUpdateResponse, error) {
	out := new(SignUpdateResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/SignUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) VerifyUpdate(ctx context.Context, in *VerifyUpdateRequest, opts ...grpc.CallOption) (*VerifyUpdateResponse, error) {
	out := new(VerifyUpdateResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/VerifyUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) SignFinal(ctx context.Context, in *SignFinalRequest, opts ...grpc.CallOption) (*SignFinalResponse, error) {
	out := new(SignFinalResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/SignFinal", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) VerifyFinal(ctx context.Context, in *VerifyFinalRequest, opts ...grpc.CallOption) (*VerifyFinalResponse, error) {
	out := new(VerifyFinalResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/VerifyFinal", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) Sign(ctx context.Context, in *SignRequest, opts ...grpc.CallOption) (*SignResponse, error) {
	out := new(SignResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/Sign", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) Verify(ctx context.Context, in *VerifyRequest, opts ...grpc.CallOption) (*VerifyResponse, error) {
	out := new(VerifyResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/Verify", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) SignSingle(ctx context.Context, in *SignSingleRequest, opts ...grpc.CallOption) (*SignSingleResponse, error) {
	out := new(SignSingleResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/SignSingle", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) VerifySingle(ctx context.Context, in *VerifySingleRequest, opts ...grpc.CallOption) (*VerifySingleResponse, error) {
	out := new(VerifySingleResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/VerifySingle", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) GenerateKey(ctx context.Context, in *GenerateKeyRequest, opts ...grpc.CallOption) (*GenerateKeyResponse, error) {
	out := new(GenerateKeyResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/GenerateKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) GenerateKeyPair(ctx context.Context, in *GenerateKeyPairRequest, opts ...grpc.CallOption) (*GenerateKeyPairResponse, error) {
	out := new(GenerateKeyPairResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/GenerateKeyPair", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) WrapKey(ctx context.Context, in *WrapKeyRequest, opts ...grpc.CallOption) (*WrapKeyResponse, error) {
	out := new(WrapKeyResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/WrapKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) UnwrapKey(ctx context.Context, in *UnwrapKeyRequest, opts ...grpc.CallOption) (*UnwrapKeyResponse, error) {
	out := new(UnwrapKeyResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/UnwrapKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) DeriveKey(ctx context.Context, in *DeriveKeyRequest, opts ...grpc.CallOption) (*DeriveKeyResponse, error) {
	out := new(DeriveKeyResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/DeriveKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) GetMechanismList(ctx context.Context, in *GetMechanismListRequest, opts ...grpc.CallOption) (*GetMechanismListResponse, error) {
	out := new(GetMechanismListResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/GetMechanismList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) GetMechanismInfo(ctx context.Context, in *GetMechanismInfoRequest, opts ...grpc.CallOption) (*GetMechanismInfoResponse, error) {
	out := new(GetMechanismInfoResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/GetMechanismInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) GetAttributeValue(ctx context.Context, in *GetAttributeValueRequest, opts ...grpc.CallOption) (*GetAttributeValueResponse, error) {
	out := new(GetAttributeValueResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/GetAttributeValue", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) SetAttributeValue(ctx context.Context, in *SetAttributeValueRequest, opts ...grpc.CallOption) (*SetAttributeValueResponse, error) {
	out := new(SetAttributeValueResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/SetAttributeValue", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Crypto service

type CryptoServer interface {
	// See https://www-03.ibm.com/security/cryptocards/pciecc/pdf/ep11-structure.pdf for
	// further documentation
	// CK_RV m_GenerateRandom (
	//     CK_BYTE_PTR rnd, CK_ULONG rndlen,
	//     target_t target) ;
	GenerateRandom(context.Context, *GenerateRandomRequest) (*GenerateRandomResponse, error)
	// CK_RV m_DigestInit (
	//     unsigned char *state, size_t *statelen,
	//     const CK_MECHANISM_PTR mech,
	//     target_t target) ;
	DigestInit(context.Context, *DigestInitRequest) (*DigestInitResponse, error)
	// CK_RV m_Digest (
	//     const unsigned char *state, size_t statelen,
	//     CK_BYTE_PTR data, CK_ULONG datalen,
	//     CK_BYTE_PTR digest, CK_ULONG_PTR digestlen,
	//     target_t target) ;
	Digest(context.Context, *DigestRequest) (*DigestResponse, error)
	// CK_RV m_DigestUpdate (
	//     unsigned char *state, size_t statelen,
	//     CK_BYTE_PTR data, CK_ULONG datalen,
	//     target_t target) ;
	DigestUpdate(context.Context, *DigestUpdateRequest) (*DigestUpdateResponse, error)
	// CK_RV m_DigestKey (
	//     unsigned char *state, size_t statelen,
	//     const unsigned char *key, size_t keylen,
	//     target_t target) ;
	DigestKey(context.Context, *DigestKeyRequest) (*DigestKeyResponse, error)
	// CK_RV m_DigestFinal (
	//     const unsigned char *state, size_t statelen,
	//     CK_BYTE_PTR digest, CK_ULONG_PTR digestlen,
	//     target_t target) ;
	DigestFinal(context.Context, *DigestFinalRequest) (*DigestFinalResponse, error)
	// CK_RV m_DigestSingle (
	//     CK_MECHANISM_PTR mech,
	//     CK_BYTE_PTR data, CK_ULONG datalen,
	//     CK_BYTE_PTR digest, CK_ULONG_PTR digestlen,
	//     target_t target) ;
	DigestSingle(context.Context, *DigestSingleRequest) (*DigestSingleResponse, error)
	// CK_RV m_EncryptInit (
	//     unsigned char *state, size_t *statelen,
	//     CK_MECHANISM_PTR mech,
	//     const unsigned char *key, size_t keylen,
	//     target_t target) ;
	EncryptInit(context.Context, *EncryptInitRequest) (*EncryptInitResponse, error)
	// CK_RV m_DecryptInit (
	//     unsigned char *state, size_t *statelen,
	//     CK_MECHANISM_PTR mech,
	//     const unsigned char *key, size_t keylen,
	//     target_t target) ;
	DecryptInit(context.Context, *DecryptInitRequest) (*DecryptInitResponse, error)
	// CK_RV m_EncryptUpdate (
	//     unsigned char *state, size_t statelen,
	//     CK_BYTE_PTR plain, CK_ULONG plainlen,
	//     CK_BYTE_PTR ciphered, CK_ULONG_PTR cipheredlen,
	//     target_t target) ;
	EncryptUpdate(context.Context, *EncryptUpdateRequest) (*EncryptUpdateResponse, error)
	// CK_RV m_DecryptUpdate (
	//     unsigned char *state, size_t statelen,
	//     CK_BYTE_PTR ciphered, CK_ULONG cipheredlen,
	//     CK_BYTE_PTR plain, CK_ULONG_PTR plainlen,
	//     target_t target) ;
	DecryptUpdate(context.Context, *DecryptUpdateRequest) (*DecryptUpdateResponse, error)
	// CK_RV m_Encrypt (
	//     const unsigned char *state, size_t statelen,
	//     CK_BYTE_PTR plain, CK_ULONG plainlen,
	//     CK_BYTE_PTR ciphered, CK_ULONG_PTR cipheredlen,
	//     target_t target) ;
	Encrypt(context.Context, *EncryptRequest) (*EncryptResponse, error)
	// CK_RV m_Decrypt (
	//     const unsigned char *state, size_t statelen,
	//     CK_BYTE_PTR ciphered, CK_ULONG cipheredlen,
	//     CK_BYTE_PTR plain, CK_ULONG_PTR plainlen,
	//     target_t target) ;
	Decrypt(context.Context, *DecryptRequest) (*DecryptResponse, error)
	// CK_RV m_EncryptFinal (
	//     const unsigned char *state, size_t statelen,
	//     CK_BYTE_PTR ciphered, CK_ULONG_PTR cipheredlen,
	//     target_t target) ;
	EncryptFinal(context.Context, *EncryptFinalRequest) (*EncryptFinalResponse, error)
	// CK_RV m_DecryptFinal (
	//     const unsigned char *state, size_t statelen,
	//     CK_BYTE_PTR plain, CK_ULONG_PTR plainlen,
	//     target_t target) ;
	DecryptFinal(context.Context, *DecryptFinalRequest) (*DecryptFinalResponse, error)
	// CK_RV m_EncryptSingle (
	//     const unsigned char *key, size_t keylen,
	//     CK_MECHANISM_PTR mech,
	//     CK_BYTE_PTR plain, CK_ULONG plainlen,
	//     CK_BYTE_PTR ciphered, CK_ULONG_PTR cipheredlen,
	//     target_t target) ;
	EncryptSingle(context.Context, *EncryptSingleRequest) (*EncryptSingleResponse, error)
	// CK_RV m_DecryptSingle (
	//     const unsigned char *key, size_t keylen,
	//     CK_MECHANISM_PTR mech,
	//     CK_BYTE_PTR ciphered, CK_ULONG cipheredlen,
	//     CK_BYTE_PTR plain, CK_ULONG_PTR plainlen,
	//     target_t target) ;
	DecryptSingle(context.Context, *DecryptSingleRequest) (*DecryptSingleResponse, error)
	// CK_RV m_SignInit (
	//     unsigned char *state, size_t *statelen,
	//     CK_MECHANISM_PTR mech,
	//     const unsigned char *privKey, size_t privKeylen,
	//     target_t target) ;
	SignInit(context.Context, *SignInitRequest) (*SignInitResponse, error)
	// CK_RV m_VerifyInit (
	//     unsigned char *state, size_t *statelen,
	//     CK_MECHANISM_PTR mech,
	//     const unsigned char *pubKey, size_t pubKeylen,
	//     target_t target) ;
	VerifyInit(context.Context, *VerifyInitRequest) (*VerifyInitResponse, error)
	// CK_RV m_SignUpdate (
	//     unsigned char *state, size_t statelen,
	//     CK_BYTE_PTR data, CK_ULONG datalen,
	//     target_t target) ;
	SignUpdate(context.Context, *SignUpdateRequest) (*SignUpdateResponse, error)
	// CK_RV m_VerifyUpdate (
	//     unsigned char *state, size_t statelen,
	//     CK_BYTE_PTR data, CK_ULONG datalen,
	//     target_t target) ;
	VerifyUpdate(context.Context, *VerifyUpdateRequest) (*VerifyUpdateResponse, error)
	// CK_RV m_SignFinal (
	//     const unsigned char *state, size_t statelen,
	//     CK_BYTE_PTR signature, CK_ULONG_PTR signaturelen,
	//     target_t target) ;
	SignFinal(context.Context, *SignFinalRequest) (*SignFinalResponse, error)
	// CK_RV m_VerifyFinal (
	//     const unsigned char *state, size_t statelen,
	//     CK_BYTE_PTR signature, CK_ULONG signaturelen,
	//     target_t target) ;
	VerifyFinal(context.Context, *VerifyFinalRequest) (*VerifyFinalResponse, error)
	// CK_RV m_Sign (
	//     const unsigned char *state, size_t statelen,
	//     CK_BYTE_PTR data, CK_ULONG datalen,
	//     CK_BYTE_PTR signature, CK_ULONG_PTR signaturelen,
	//     target_t target) ;
	Sign(context.Context, *SignRequest) (*SignResponse, error)
	// CK_RV m_Verify (
	//     const unsigned char *state, size_t statelen,
	//     CK_BYTE_PTR data, CK_ULONG datalen,
	//     CK_BYTE_PTR signature, CK_ULONG signaturelen,
	//     target_t target) ;
	Verify(context.Context, *VerifyRequest) (*VerifyResponse, error)
	// CK_RV m_SignSingle (
	//     const unsigned char *privKey, size_t privKeylen,
	//     CK_MECHANISM_PTR mech,
	//     CK_BYTE_PTR data, CK_ULONG datalen,
	//     CK_BYTE_PTR signature, CK_ULONG_PTR signaturelen,
	//     target_t target) ;
	SignSingle(context.Context, *SignSingleRequest) (*SignSingleResponse, error)
	// CK_RV m_VerifySingle (
	//     const unsigned char *pubKey, size_t pubKeylen,
	//     CK_MECHANISM_PTR mech,
	//     CK_BYTE_PTR data, CK_ULONG datalen,
	//     CK_BYTE_PTR signature, CK_ULONG signaturelen,
	//     target_t target) ;
	VerifySingle(context.Context, *VerifySingleRequest) (*VerifySingleResponse, error)
	// CK_RV m_GenerateKey (
	//     CK_MECHANISM_PTR mech,
	//     CK_ATTRIBUTE_PTR template, CK_ULONG templatelen,
	//     const unsigned char *pin, size_t pinlen,
	//     unsigned char *key, size_t *keylen,
	//     unsigned char *checkSum, size_t *checkSumlen,
	//     target_t target) ;
	GenerateKey(context.Context, *GenerateKeyRequest) (*GenerateKeyResponse, error)
	// CK_RV m_GenerateKeyPair (
	//     CK_MECHANISM_PTR mech,
	//     CK_ATTRIBUTE_PTR pubKeyTemplate, CK_ULONG pubKeyTemplatelen,
	//     CK_ATTRIBUTE_PTR privKeyTemplate, CK_ULONG privKeyTemplatelen,
	//     const unsigned char *pin, size_t pinlen,
	//     unsigned char *privKey, size_t *privKeylen,
	//     unsigned char *pubKey, size_t *pubKeylen,
	//     target_t target) ;
	GenerateKeyPair(context.Context, *GenerateKeyPairRequest) (*GenerateKeyPairResponse, error)
	// CK_RV m_WrapKey (
	//     const unsigned char *key, size_t keylen,
	//     const unsigned char *keK, size_t keKlen,
	//     const unsigned char *macKey, size_t macKeylen,
	//     const CK_MECHANISM_PTR mech,
	//     CK_BYTE_PTR wrapped, CK_ULONG_PTR wrappedlen,
	//     target_t target) ;
	WrapKey(context.Context, *WrapKeyRequest) (*WrapKeyResponse, error)
	// CK_RV m_UnwrapKey (
	//     const CK_BYTE_PTR wrapped, CK_ULONG wrappedlen,
	//     const unsigned char *keK, size_t keKlen,
	//     const unsigned char *macKey, size_t macKeylen,
	//     const unsigned char *pin, size_t pinlen,
	//     const CK_MECHANISM_PTR mech,
	//     const CK_ATTRIBUTE_PTR template, CK_ULONG templatelen,
	//     unsigned char *unwrapped, size_t *unwrappedlen,
	//     CK_BYTE_PTR checkSum, CK_ULONG *checkSumlen,
	//     target_t target) ;
	UnwrapKey(context.Context, *UnwrapKeyRequest) (*UnwrapKeyResponse, error)
	// CK_RV m_DeriveKey (
	//     CK_MECHANISM_PTR mech,
	//     CK_ATTRIBUTE_PTR template, CK_ULONG templatelen,
	//     const unsigned char *baseKey, size_t baseKeylen,
	//     const unsigned char *data, size_t datalen,
	//     const unsigned char *pin, size_t pinlen,
	//     unsigned char *newKey, size_t *newKeylen,
	//     unsigned char *checkSum, size_t *checkSumlen,
	//     target_t target) ;
	DeriveKey(context.Context, *DeriveKeyRequest) (*DeriveKeyResponse, error)
	// CK_RV m_GetMechanismList (
	//     CK_SLOT_ID slot,
	//     CK_MECHANISM_TYPE_PTR mechs, CK_ULONG_PTR mechslen,
	//     target_t target) ;
	GetMechanismList(context.Context, *GetMechanismListRequest) (*GetMechanismListResponse, error)
	// CK_RV m_GetMechanismInfo (
	//     CK_SLOT_ID slot,
	//     CK_MECHANISM_TYPE mech,
	//     CK_MECHANISM_INFO_PTR mechInfo,
	//     target_t target) ;
	GetMechanismInfo(context.Context, *GetMechanismInfoRequest) (*GetMechanismInfoResponse, error)
	// CK_RV m_GetAttributeValue (
	//     const unsigned char *object, size_t objectlen,
	//     CK_ATTRIBUTE_PTR attributes, CK_ULONG attributeslen,
	//     target_t target) ;
	GetAttributeValue(context.Context, *GetAttributeValueRequest) (*GetAttributeValueResponse, error)
	// CK_RV m_SetAttributeValue (
	//     unsigned char *object, size_t objectlen,
	//     CK_ATTRIBUTE_PTR attributes, CK_ULONG attributeslen,
	//     target_t target) ;
	SetAttributeValue(context.Context, *SetAttributeValueRequest) (*SetAttributeValueResponse, error)
}

func RegisterCryptoServer(s *grpc.Server, srv CryptoServer) {
	s.RegisterService(&_Crypto_serviceDesc, srv)
}

func _Crypto_GenerateRandom_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateRandomRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).GenerateRandom(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/GenerateRandom",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).GenerateRandom(ctx, req.(*GenerateRandomRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_DigestInit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DigestInitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).DigestInit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/DigestInit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).DigestInit(ctx, req.(*DigestInitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_Digest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DigestRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).Digest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/Digest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).Digest(ctx, req.(*DigestRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_DigestUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DigestUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).DigestUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/DigestUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).DigestUpdate(ctx, req.(*DigestUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_DigestKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DigestKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).DigestKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/DigestKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).DigestKey(ctx, req.(*DigestKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_DigestFinal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DigestFinalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).DigestFinal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/DigestFinal",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).DigestFinal(ctx, req.(*DigestFinalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_DigestSingle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DigestSingleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).DigestSingle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/DigestSingle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).DigestSingle(ctx, req.(*DigestSingleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_EncryptInit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EncryptInitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).EncryptInit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/EncryptInit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).EncryptInit(ctx, req.(*EncryptInitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_DecryptInit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DecryptInitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).DecryptInit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/DecryptInit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).DecryptInit(ctx, req.(*DecryptInitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_EncryptUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EncryptUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).EncryptUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/EncryptUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).EncryptUpdate(ctx, req.(*EncryptUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_DecryptUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DecryptUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).DecryptUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/DecryptUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).DecryptUpdate(ctx, req.(*DecryptUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_Encrypt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EncryptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).Encrypt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/Encrypt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).Encrypt(ctx, req.(*EncryptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_Decrypt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DecryptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).Decrypt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/Decrypt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).Decrypt(ctx, req.(*DecryptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_EncryptFinal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EncryptFinalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).EncryptFinal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/EncryptFinal",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).EncryptFinal(ctx, req.(*EncryptFinalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_DecryptFinal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DecryptFinalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).DecryptFinal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/DecryptFinal",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).DecryptFinal(ctx, req.(*DecryptFinalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_EncryptSingle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EncryptSingleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).EncryptSingle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/EncryptSingle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).EncryptSingle(ctx, req.(*EncryptSingleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_DecryptSingle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DecryptSingleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).DecryptSingle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/DecryptSingle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).DecryptSingle(ctx, req.(*DecryptSingleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_SignInit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignInitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).SignInit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/SignInit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).SignInit(ctx, req.(*SignInitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_VerifyInit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyInitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).VerifyInit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/VerifyInit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).VerifyInit(ctx, req.(*VerifyInitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_SignUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).SignUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/SignUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).SignUpdate(ctx, req.(*SignUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_VerifyUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).VerifyUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/VerifyUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).VerifyUpdate(ctx, req.(*VerifyUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_SignFinal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignFinalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).SignFinal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/SignFinal",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).SignFinal(ctx, req.(*SignFinalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_VerifyFinal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyFinalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).VerifyFinal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/VerifyFinal",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).VerifyFinal(ctx, req.(*VerifyFinalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_Sign_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).Sign(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/Sign",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).Sign(ctx, req.(*SignRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_Verify_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).Verify(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/Verify",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).Verify(ctx, req.(*VerifyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_SignSingle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignSingleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).SignSingle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/SignSingle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).SignSingle(ctx, req.(*SignSingleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_VerifySingle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifySingleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).VerifySingle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/VerifySingle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).VerifySingle(ctx, req.(*VerifySingleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_GenerateKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).GenerateKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/GenerateKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).GenerateKey(ctx, req.(*GenerateKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_GenerateKeyPair_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateKeyPairRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).GenerateKeyPair(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/GenerateKeyPair",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).GenerateKeyPair(ctx, req.(*GenerateKeyPairRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_WrapKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WrapKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).WrapKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/WrapKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).WrapKey(ctx, req.(*WrapKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_UnwrapKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnwrapKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).UnwrapKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/UnwrapKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).UnwrapKey(ctx, req.(*UnwrapKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_DeriveKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeriveKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).DeriveKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/DeriveKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).DeriveKey(ctx, req.(*DeriveKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_GetMechanismList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMechanismListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).GetMechanismList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/GetMechanismList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).GetMechanismList(ctx, req.(*GetMechanismListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_GetMechanismInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMechanismInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).GetMechanismInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/GetMechanismInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).GetMechanismInfo(ctx, req.(*GetMechanismInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_GetAttributeValue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAttributeValueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).GetAttributeValue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/GetAttributeValue",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).GetAttributeValue(ctx, req.(*GetAttributeValueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_SetAttributeValue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetAttributeValueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).SetAttributeValue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/SetAttributeValue",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).SetAttributeValue(ctx, req.(*SetAttributeValueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Crypto_serviceDesc = grpc.ServiceDesc{
	ServiceName: "grep11.Crypto",
	HandlerType: (*CryptoServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GenerateRandom",
			Handler:    _Crypto_GenerateRandom_Handler,
		},
		{
			MethodName: "DigestInit",
			Handler:    _Crypto_DigestInit_Handler,
		},
		{
			MethodName: "Digest",
			Handler:    _Crypto_Digest_Handler,
		},
		{
			MethodName: "DigestUpdate",
			Handler:    _Crypto_DigestUpdate_Handler,
		},
		{
			MethodName: "DigestKey",
			Handler:    _Crypto_DigestKey_Handler,
		},
		{
			MethodName: "DigestFinal",
			Handler:    _Crypto_DigestFinal_Handler,
		},
		{
			MethodName: "DigestSingle",
			Handler:    _Crypto_DigestSingle_Handler,
		},
		{
			MethodName: "EncryptInit",
			Handler:    _Crypto_EncryptInit_Handler,
		},
		{
			MethodName: "DecryptInit",
			Handler:    _Crypto_DecryptInit_Handler,
		},
		{
			MethodName: "EncryptUpdate",
			Handler:    _Crypto_EncryptUpdate_Handler,
		},
		{
			MethodName: "DecryptUpdate",
			Handler:    _Crypto_DecryptUpdate_Handler,
		},
		{
			MethodName: "Encrypt",
			Handler:    _Crypto_Encrypt_Handler,
		},
		{
			MethodName: "Decrypt",
			Handler:    _Crypto_Decrypt_Handler,
		},
		{
			MethodName: "EncryptFinal",
			Handler:    _Crypto_EncryptFinal_Handler,
		},
		{
			MethodName: "DecryptFinal",
			Handler:    _Crypto_DecryptFinal_Handler,
		},
		{
			MethodName: "EncryptSingle",
			Handler:    _Crypto_EncryptSingle_Handler,
		},
		{
			MethodName: "DecryptSingle",
			Handler:    _Crypto_DecryptSingle_Handler,
		},
		{
			MethodName: "SignInit",
			Handler:    _Crypto_SignInit_Handler,
		},
		{
			MethodName: "VerifyInit",
			Handler:    _Crypto_VerifyInit_Handler,
		},
		{
			MethodName: "SignUpdate",
			Handler:    _Crypto_SignUpdate_Handler,
		},
		{
			MethodName: "VerifyUpdate",
			Handler:    _Crypto_VerifyUpdate_Handler,
		},
		{
			MethodName: "SignFinal",
			Handler:    _Crypto_SignFinal_Handler,
		},
		{
			MethodName: "VerifyFinal",
			Handler:    _Crypto_VerifyFinal_Handler,
		},
		{
			MethodName: "Sign",
			Handler:    _Crypto_Sign_Handler,
		},
		{
			MethodName: "Verify",
			Handler:    _Crypto_Verify_Handler,
		},
		{
			MethodName: "SignSingle",
			Handler:    _Crypto_SignSingle_Handler,
		},
		{
			MethodName: "VerifySingle",
			Handler:    _Crypto_VerifySingle_Handler,
		},
		{
			MethodName: "GenerateKey",
			Handler:    _Crypto_GenerateKey_Handler,
		},
		{
			MethodName: "GenerateKeyPair",
			Handler:    _Crypto_GenerateKeyPair_Handler,
		},
		{
			MethodName: "WrapKey",
			Handler:    _Crypto_WrapKey_Handler,
		},
		{
			MethodName: "UnwrapKey",
			Handler:    _Crypto_UnwrapKey_Handler,
		},
		{
			MethodName: "DeriveKey",
			Handler:    _Crypto_DeriveKey_Handler,
		},
		{
			MethodName: "GetMechanismList",
			Handler:    _Crypto_GetMechanismList_Handler,
		},
		{
			MethodName: "GetMechanismInfo",
			Handler:    _Crypto_GetMechanismInfo_Handler,
		},
		{
			MethodName: "GetAttributeValue",
			Handler:    _Crypto_GetAttributeValue_Handler,
		},
		{
			MethodName: "SetAttributeValue",
			Handler:    _Crypto_SetAttributeValue_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "server.proto",
}

func (m *GenerateRandomRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GenerateRandomRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Len != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintServer(dAtA, i, uint64(m.Len))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GenerateRandomResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GenerateRandomResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Rnd) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.Rnd)))
		i += copy(dAtA[i:], m.Rnd)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DigestInitRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DigestInitRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mech != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintServer(dAtA, i, uint64(m.Mech.Size()))
		n1, err := m.Mech.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DigestInitResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DigestInitResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.State) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.State)))
		i += copy(dAtA[i:], m.State)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DigestRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DigestRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.State) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.State)))
		i += copy(dAtA[i:], m.State)
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DigestResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DigestResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Digest) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.Digest)))
		i += copy(dAtA[i:], m.Digest)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DigestUpdateRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DigestUpdateRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.State) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.State)))
		i += copy(dAtA[i:], m.State)
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DigestUpdateResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DigestUpdateResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.State) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.State)))
		i += copy(dAtA[i:], m.State)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DigestKeyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DigestKeyRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.State) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.State)))
		i += copy(dAtA[i:], m.State)
	}
	if len(m.Key) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DigestKeyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DigestKeyResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.State) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.State)))
		i += copy(dAtA[i:], m.State)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DigestFinalRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DigestFinalRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.State) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.State)))
		i += copy(dAtA[i:], m.State)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DigestFinalResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DigestFinalResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Digest) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.Digest)))
		i += copy(dAtA[i:], m.Digest)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DigestSingleRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DigestSingleRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mech != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintServer(dAtA, i, uint64(m.Mech.Size()))
		n2, err := m.Mech.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DigestSingleResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DigestSingleResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Digest) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.Digest)))
		i += copy(dAtA[i:], m.Digest)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *EncryptInitRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncryptInitRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mech != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintServer(dAtA, i, uint64(m.Mech.Size()))
		n3, err := m.Mech.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if len(m.Key) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *EncryptInitResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncryptInitResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.State) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.State)))
		i += copy(dAtA[i:], m.State)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DecryptInitRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DecryptInitRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mech != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintServer(dAtA, i, uint64(m.Mech.Size()))
		n4, err := m.Mech.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if len(m.Key) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DecryptInitResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DecryptInitResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.State) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.State)))
		i += copy(dAtA[i:], m.State)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *EncryptUpdateRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncryptUpdateRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.State) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.State)))
		i += copy(dAtA[i:], m.State)
	}
	if len(m.Plain) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.Plain)))
		i += copy(dAtA[i:], m.Plain)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *EncryptUpdateResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncryptUpdateResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.State) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.State)))
		i += copy(dAtA[i:], m.State)
	}
	if len(m.Ciphered) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.Ciphered)))
		i += copy(dAtA[i:], m.Ciphered)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DecryptUpdateRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DecryptUpdateRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.State) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.State)))
		i += copy(dAtA[i:], m.State)
	}
	if len(m.Ciphered) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.Ciphered)))
		i += copy(dAtA[i:], m.Ciphered)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DecryptUpdateResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DecryptUpdateResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.State) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.State)))
		i += copy(dAtA[i:], m.State)
	}
	if len(m.Plain) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.Plain)))
		i += copy(dAtA[i:], m.Plain)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *EncryptRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncryptRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.State) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.State)))
		i += copy(dAtA[i:], m.State)
	}
	if len(m.Plain) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.Plain)))
		i += copy(dAtA[i:], m.Plain)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *EncryptResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncryptResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ciphered) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.Ciphered)))
		i += copy(dAtA[i:], m.Ciphered)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DecryptRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DecryptRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.State) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.State)))
		i += copy(dAtA[i:], m.State)
	}
	if len(m.Ciphered) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.Ciphered)))
		i += copy(dAtA[i:], m.Ciphered)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DecryptResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DecryptResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Plain) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.Plain)))
		i += copy(dAtA[i:], m.Plain)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *EncryptFinalRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncryptFinalRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.State) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.State)))
		i += copy(dAtA[i:], m.State)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *EncryptFinalResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncryptFinalResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ciphered) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.Ciphered)))
		i += copy(dAtA[i:], m.Ciphered)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DecryptFinalRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DecryptFinalRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.State) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.State)))
		i += copy(dAtA[i:], m.State)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DecryptFinalResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DecryptFinalResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Plain) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.Plain)))
		i += copy(dAtA[i:], m.Plain)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *EncryptSingleRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncryptSingleRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if m.Mech != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintServer(dAtA, i, uint64(m.Mech.Size()))
		n5, err := m.Mech.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if len(m.Plain) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.Plain)))
		i += copy(dAtA[i:], m.Plain)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *EncryptSingleResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncryptSingleResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ciphered) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.Ciphered)))
		i += copy(dAtA[i:], m.Ciphered)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DecryptSingleRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DecryptSingleRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if m.Mech != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintServer(dAtA, i, uint64(m.Mech.Size()))
		n6, err := m.Mech.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if len(m.Ciphered) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.Ciphered)))
		i += copy(dAtA[i:], m.Ciphered)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DecryptSingleResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DecryptSingleResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Plain) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.Plain)))
		i += copy(dAtA[i:], m.Plain)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SignInitRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignInitRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mech != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintServer(dAtA, i, uint64(m.Mech.Size()))
		n7, err := m.Mech.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if len(m.PrivKey) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.PrivKey)))
		i += copy(dAtA[i:], m.PrivKey)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SignInitResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignInitResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.State) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.State)))
		i += copy(dAtA[i:], m.State)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *VerifyInitRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerifyInitRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mech != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintServer(dAtA, i, uint64(m.Mech.Size()))
		n8, err := m.Mech.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if len(m.PubKey) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.PubKey)))
		i += copy(dAtA[i:], m.PubKey)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *VerifyInitResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerifyInitResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.State) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.State)))
		i += copy(dAtA[i:], m.State)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SignUpdateRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignUpdateRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.State) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.State)))
		i += copy(dAtA[i:], m.State)
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SignUpdateResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignUpdateResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.State) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.State)))
		i += copy(dAtA[i:], m.State)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *VerifyUpdateRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerifyUpdateRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.State) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.State)))
		i += copy(dAtA[i:], m.State)
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *VerifyUpdateResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerifyUpdateResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.State) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.State)))
		i += copy(dAtA[i:], m.State)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SignFinalRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignFinalRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.State) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.State)))
		i += copy(dAtA[i:], m.State)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SignFinalResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignFinalResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Signature) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.Signature)))
		i += copy(dAtA[i:], m.Signature)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *VerifyFinalRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerifyFinalRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.State) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.State)))
		i += copy(dAtA[i:], m.State)
	}
	if len(m.Signature) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.Signature)))
		i += copy(dAtA[i:], m.Signature)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *VerifyFinalResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerifyFinalResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SignRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.State) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.State)))
		i += copy(dAtA[i:], m.State)
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SignResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Signature) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.Signature)))
		i += copy(dAtA[i:], m.Signature)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *VerifyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerifyRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.State) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.State)))
		i += copy(dAtA[i:], m.State)
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if len(m.Signature) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.Signature)))
		i += copy(dAtA[i:], m.Signature)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *VerifyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerifyResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SignSingleRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignSingleRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PrivKey) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.PrivKey)))
		i += copy(dAtA[i:], m.PrivKey)
	}
	if m.Mech != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintServer(dAtA, i, uint64(m.Mech.Size()))
		n9, err := m.Mech.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SignSingleResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignSingleResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Signature) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.Signature)))
		i += copy(dAtA[i:], m.Signature)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *VerifySingleRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerifySingleRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PubKey) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.PubKey)))
		i += copy(dAtA[i:], m.PubKey)
	}
	if m.Mech != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintServer(dAtA, i, uint64(m.Mech.Size()))
		n10, err := m.Mech.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if len(m.Signature) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.Signature)))
		i += copy(dAtA[i:], m.Signature)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *VerifySingleResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerifySingleResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GenerateKeyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GenerateKeyRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mech != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintServer(dAtA, i, uint64(m.Mech.Size()))
		n11, err := m.Mech.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if len(m.Template) > 0 {
		for k, _ := range m.Template {
			dAtA[i] = 0x12
			i++
			v := m.Template[k]
			byteSize := 0
			if len(v) > 0 {
				byteSize = 1 + len(v) + sovServer(uint64(len(v)))
			}
			mapSize := 1 + sovServer(uint64(k)) + byteSize
			i = encodeVarintServer(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintServer(dAtA, i, uint64(k))
			if len(v) > 0 {
				dAtA[i] = 0x12
				i++
				i = encodeVarintServer(dAtA, i, uint64(len(v)))
				i += copy(dAtA[i:], v)
			}
		}
	}
	if len(m.KeyId) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.KeyId)))
		i += copy(dAtA[i:], m.KeyId)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GenerateKeyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GenerateKeyResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.CheckSum) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.CheckSum)))
		i += copy(dAtA[i:], m.CheckSum)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GenerateKeyPairRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GenerateKeyPairRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mech != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintServer(dAtA, i, uint64(m.Mech.Size()))
		n12, err := m.Mech.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if len(m.PubKeyTemplate) > 0 {
		for k, _ := range m.PubKeyTemplate {
			dAtA[i] = 0x12
			i++
			v := m.PubKeyTemplate[k]
			byteSize := 0
			if len(v) > 0 {
				byteSize = 1 + len(v) + sovServer(uint64(len(v)))
			}
			mapSize := 1 + sovServer(uint64(k)) + byteSize
			i = encodeVarintServer(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintServer(dAtA, i, uint64(k))
			if len(v) > 0 {
				dAtA[i] = 0x12
				i++
				i = encodeVarintServer(dAtA, i, uint64(len(v)))
				i += copy(dAtA[i:], v)
			}
		}
	}
	if len(m.PrivKeyTemplate) > 0 {
		for k, _ := range m.PrivKeyTemplate {
			dAtA[i] = 0x1a
			i++
			v := m.PrivKeyTemplate[k]
			byteSize := 0
			if len(v) > 0 {
				byteSize = 1 + len(v) + sovServer(uint64(len(v)))
			}
			mapSize := 1 + sovServer(uint64(k)) + byteSize
			i = encodeVarintServer(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintServer(dAtA, i, uint64(k))
			if len(v) > 0 {
				dAtA[i] = 0x12
				i++
				i = encodeVarintServer(dAtA, i, uint64(len(v)))
				i += copy(dAtA[i:], v)
			}
		}
	}
	if len(m.PrivKeyId) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.PrivKeyId)))
		i += copy(dAtA[i:], m.PrivKeyId)
	}
	if len(m.PubKeyId) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.PubKeyId)))
		i += copy(dAtA[i:], m.PubKeyId)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GenerateKeyPairResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GenerateKeyPairResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PrivKey) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.PrivKey)))
		i += copy(dAtA[i:], m.PrivKey)
	}
	if len(m.PubKey) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.PubKey)))
		i += copy(dAtA[i:], m.PubKey)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *WrapKeyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WrapKeyRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.KeK) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.KeK)))
		i += copy(dAtA[i:], m.KeK)
	}
	if len(m.MacKey) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.MacKey)))
		i += copy(dAtA[i:], m.MacKey)
	}
	if m.Mech != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintServer(dAtA, i, uint64(m.Mech.Size()))
		n13, err := m.Mech.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *WrapKeyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WrapKeyResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Wrapped) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.Wrapped)))
		i += copy(dAtA[i:], m.Wrapped)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UnwrapKeyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnwrapKeyRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Wrapped) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.Wrapped)))
		i += copy(dAtA[i:], m.Wrapped)
	}
	if len(m.KeK) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.KeK)))
		i += copy(dAtA[i:], m.KeK)
	}
	if len(m.MacKey) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.MacKey)))
		i += copy(dAtA[i:], m.MacKey)
	}
	if m.Mech != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintServer(dAtA, i, uint64(m.Mech.Size()))
		n14, err := m.Mech.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if len(m.Template) > 0 {
		for k, _ := range m.Template {
			dAtA[i] = 0x32
			i++
			v := m.Template[k]
			byteSize := 0
			if len(v) > 0 {
				byteSize = 1 + len(v) + sovServer(uint64(len(v)))
			}
			mapSize := 1 + sovServer(uint64(k)) + byteSize
			i = encodeVarintServer(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintServer(dAtA, i, uint64(k))
			if len(v) > 0 {
				dAtA[i] = 0x12
				i++
				i = encodeVarintServer(dAtA, i, uint64(len(v)))
				i += copy(dAtA[i:], v)
			}
		}
	}
	if len(m.UnwrappedId) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.UnwrappedId)))
		i += copy(dAtA[i:], m.UnwrappedId)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UnwrapKeyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnwrapKeyResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Unwrapped) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.Unwrapped)))
		i += copy(dAtA[i:], m.Unwrapped)
	}
	if len(m.CheckSum) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.CheckSum)))
		i += copy(dAtA[i:], m.CheckSum)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DeriveKeyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeriveKeyRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mech != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintServer(dAtA, i, uint64(m.Mech.Size()))
		n15, err := m.Mech.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if len(m.Template) > 0 {
		for k, _ := range m.Template {
			dAtA[i] = 0x12
			i++
			v := m.Template[k]
			byteSize := 0
			if len(v) > 0 {
				byteSize = 1 + len(v) + sovServer(uint64(len(v)))
			}
			mapSize := 1 + sovServer(uint64(k)) + byteSize
			i = encodeVarintServer(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintServer(dAtA, i, uint64(k))
			if len(v) > 0 {
				dAtA[i] = 0x12
				i++
				i = encodeVarintServer(dAtA, i, uint64(len(v)))
				i += copy(dAtA[i:], v)
			}
		}
	}
	if len(m.BaseKey) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.BaseKey)))
		i += copy(dAtA[i:], m.BaseKey)
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if len(m.NewKeyId) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.NewKeyId)))
		i += copy(dAtA[i:], m.NewKeyId)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DeriveKeyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeriveKeyResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.NewKey) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.NewKey)))
		i += copy(dAtA[i:], m.NewKey)
	}
	if len(m.CheckSum) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.CheckSum)))
		i += copy(dAtA[i:], m.CheckSum)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetMechanismListRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetMechanismListRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetMechanismListResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetMechanismListResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Mechs) > 0 {
		dAtA17 := make([]byte, len(m.Mechs)*10)
		var j16 int
		for _, num := range m.Mechs {
			for num >= 1<<7 {
				dAtA17[j16] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j16++
			}
			dAtA17[j16] = uint8(num)
			j16++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintServer(dAtA, i, uint64(j16))
		i += copy(dAtA[i:], dAtA17[:j16])
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetMechanismInfoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetMechanismInfoRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mech != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintServer(dAtA, i, uint64(m.Mech))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetMechanismInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetMechanismInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MechInfo != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintServer(dAtA, i, uint64(m.MechInfo.Size()))
		n18, err := m.MechInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetAttributeValueRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAttributeValueRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Object) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.Object)))
		i += copy(dAtA[i:], m.Object)
	}
	if len(m.Attributes) > 0 {
		for k, _ := range m.Attributes {
			dAtA[i] = 0x12
			i++
			v := m.Attributes[k]
			byteSize := 0
			if len(v) > 0 {
				byteSize = 1 + len(v) + sovServer(uint64(len(v)))
			}
			mapSize := 1 + sovServer(uint64(k)) + byteSize
			i = encodeVarintServer(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintServer(dAtA, i, uint64(k))
			if len(v) > 0 {
				dAtA[i] = 0x12
				i++
				i = encodeVarintServer(dAtA, i, uint64(len(v)))
				i += copy(dAtA[i:], v)
			}
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetAttributeValueResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAttributeValueResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Attributes) > 0 {
		for k, _ := range m.Attributes {
			dAtA[i] = 0x12
			i++
			v := m.Attributes[k]
			byteSize := 0
			if len(v) > 0 {
				byteSize = 1 + len(v) + sovServer(uint64(len(v)))
			}
			mapSize := 1 + sovServer(uint64(k)) + byteSize
			i = encodeVarintServer(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintServer(dAtA, i, uint64(k))
			if len(v) > 0 {
				dAtA[i] = 0x12
				i++
				i = encodeVarintServer(dAtA, i, uint64(len(v)))
				i += copy(dAtA[i:], v)
			}
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SetAttributeValueRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetAttributeValueRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Object) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.Object)))
		i += copy(dAtA[i:], m.Object)
	}
	if len(m.Attributes) > 0 {
		for k, _ := range m.Attributes {
			dAtA[i] = 0x12
			i++
			v := m.Attributes[k]
			byteSize := 0
			if len(v) > 0 {
				byteSize = 1 + len(v) + sovServer(uint64(len(v)))
			}
			mapSize := 1 + sovServer(uint64(k)) + byteSize
			i = encodeVarintServer(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintServer(dAtA, i, uint64(k))
			if len(v) > 0 {
				dAtA[i] = 0x12
				i++
				i = encodeVarintServer(dAtA, i, uint64(len(v)))
				i += copy(dAtA[i:], v)
			}
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SetAttributeValueResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetAttributeValueResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Object) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.Object)))
		i += copy(dAtA[i:], m.Object)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Mechanism) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Mechanism) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mechanism != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintServer(dAtA, i, uint64(m.Mechanism))
	}
	if len(m.Parameter) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.Parameter)))
		i += copy(dAtA[i:], m.Parameter)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MechanismInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MechanismInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MinKeySize != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintServer(dAtA, i, uint64(m.MinKeySize))
	}
	if m.MaxKeySize != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintServer(dAtA, i, uint64(m.MaxKeySize))
	}
	if m.Flags != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintServer(dAtA, i, uint64(m.Flags))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Grep11Error) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Grep11Error) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintServer(dAtA, i, uint64(m.Code))
	}
	if len(m.Detail) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintServer(dAtA, i, uint64(len(m.Detail)))
		i += copy(dAtA[i:], m.Detail)
	}
	if m.Retry {
		dAtA[i] = 0x18
		i++
		if m.Retry {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintServer(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *GenerateRandomRequest) Size() (n int) {
	var l int
	_ = l
	if m.Len != 0 {
		n += 1 + sovServer(uint64(m.Len))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GenerateRandomResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.Rnd)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DigestInitRequest) Size() (n int) {
	var l int
	_ = l
	if m.Mech != nil {
		l = m.Mech.Size()
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DigestInitResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DigestRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DigestResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.Digest)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DigestUpdateRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DigestUpdateResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DigestKeyRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DigestKeyResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DigestFinalRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DigestFinalResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.Digest)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DigestSingleRequest) Size() (n int) {
	var l int
	_ = l
	if m.Mech != nil {
		l = m.Mech.Size()
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DigestSingleResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.Digest)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EncryptInitRequest) Size() (n int) {
	var l int
	_ = l
	if m.Mech != nil {
		l = m.Mech.Size()
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EncryptInitResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DecryptInitRequest) Size() (n int) {
	var l int
	_ = l
	if m.Mech != nil {
		l = m.Mech.Size()
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DecryptInitResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EncryptUpdateRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.Plain)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EncryptUpdateResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.Ciphered)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DecryptUpdateRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.Ciphered)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DecryptUpdateResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.Plain)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EncryptRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.Plain)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EncryptResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.Ciphered)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DecryptRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.Ciphered)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DecryptResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.Plain)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EncryptFinalRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EncryptFinalResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.Ciphered)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DecryptFinalRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DecryptFinalResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.Plain)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EncryptSingleRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.Mech != nil {
		l = m.Mech.Size()
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.Plain)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EncryptSingleResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.Ciphered)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DecryptSingleRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.Mech != nil {
		l = m.Mech.Size()
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.Ciphered)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DecryptSingleResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.Plain)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SignInitRequest) Size() (n int) {
	var l int
	_ = l
	if m.Mech != nil {
		l = m.Mech.Size()
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.PrivKey)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SignInitResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VerifyInitRequest) Size() (n int) {
	var l int
	_ = l
	if m.Mech != nil {
		l = m.Mech.Size()
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.PubKey)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VerifyInitResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SignUpdateRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SignUpdateResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VerifyUpdateRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VerifyUpdateResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SignFinalRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SignFinalResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VerifyFinalRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VerifyFinalResponse) Size() (n int) {
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SignRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SignResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VerifyRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VerifyResponse) Size() (n int) {
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SignSingleRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.PrivKey)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.Mech != nil {
		l = m.Mech.Size()
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SignSingleResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VerifySingleRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.PubKey)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.Mech != nil {
		l = m.Mech.Size()
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VerifySingleResponse) Size() (n int) {
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GenerateKeyRequest) Size() (n int) {
	var l int
	_ = l
	if m.Mech != nil {
		l = m.Mech.Size()
		n += 1 + l + sovServer(uint64(l))
	}
	if len(m.Template) > 0 {
		for k, v := range m.Template {
			_ = k
			_ = v
			l = 0
			if len(v) > 0 {
				l = 1 + len(v) + sovServer(uint64(len(v)))
			}
			mapEntrySize := 1 + sovServer(uint64(k)) + l
			n += mapEntrySize + 1 + sovServer(uint64(mapEntrySize))
		}
	}
	l = len(m.KeyId)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GenerateKeyResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.CheckSum)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GenerateKeyPairRequest) Size() (n int) {
	var l int
	_ = l
	if m.Mech != nil {
		l = m.Mech.Size()
		n += 1 + l + sovServer(uint64(l))
	}
	if len(m.PubKeyTemplate) > 0 {
		for k, v := range m.PubKeyTemplate {
			_ = k
			_ = v
			l = 0
			if len(v) > 0 {
				l = 1 + len(v) + sovServer(uint64(len(v)))
			}
			mapEntrySize := 1 + sovServer(uint64(k)) + l
			n += mapEntrySize + 1 + sovServer(uint64(mapEntrySize))
		}
	}
	if len(m.PrivKeyTemplate) > 0 {
		for k, v := range m.PrivKeyTemplate {
			_ = k
			_ = v
			l = 0
			if len(v) > 0 {
				l = 1 + len(v) + sovServer(uint64(len(v)))
			}
			mapEntrySize := 1 + sovServer(uint64(k)) + l
			n += mapEntrySize + 1 + sovServer(uint64(mapEntrySize))
		}
	}
	l = len(m.PrivKeyId)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.PubKeyId)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GenerateKeyPairResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.PrivKey)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.PubKey)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WrapKeyRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.KeK)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.MacKey)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.Mech != nil {
		l = m.Mech.Size()
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WrapKeyResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.Wrapped)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UnwrapKeyRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Wrapped)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.KeK)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.MacKey)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.Mech != nil {
		l = m.Mech.Size()
		n += 1 + l + sovServer(uint64(l))
	}
	if len(m.Template) > 0 {
		for k, v := range m.Template {
			_ = k
			_ = v
			l = 0
			if len(v) > 0 {
				l = 1 + len(v) + sovServer(uint64(len(v)))
			}
			mapEntrySize := 1 + sovServer(uint64(k)) + l
			n += mapEntrySize + 1 + sovServer(uint64(mapEntrySize))
		}
	}
	l = len(m.UnwrappedId)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UnwrapKeyResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.Unwrapped)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.CheckSum)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeriveKeyRequest) Size() (n int) {
	var l int
	_ = l
	if m.Mech != nil {
		l = m.Mech.Size()
		n += 1 + l + sovServer(uint64(l))
	}
	if len(m.Template) > 0 {
		for k, v := range m.Template {
			_ = k
			_ = v
			l = 0
			if len(v) > 0 {
				l = 1 + len(v) + sovServer(uint64(len(v)))
			}
			mapEntrySize := 1 + sovServer(uint64(k)) + l
			n += mapEntrySize + 1 + sovServer(uint64(mapEntrySize))
		}
	}
	l = len(m.BaseKey)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.NewKeyId)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeriveKeyResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.NewKey)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.CheckSum)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetMechanismListRequest) Size() (n int) {
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetMechanismListResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Mechs) > 0 {
		l = 0
		for _, e := range m.Mechs {
			l += sovServer(uint64(e))
		}
		n += 1 + sovServer(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetMechanismInfoRequest) Size() (n int) {
	var l int
	_ = l
	if m.Mech != 0 {
		n += 1 + sovServer(uint64(m.Mech))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetMechanismInfoResponse) Size() (n int) {
	var l int
	_ = l
	if m.MechInfo != nil {
		l = m.MechInfo.Size()
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetAttributeValueRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Object)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if len(m.Attributes) > 0 {
		for k, v := range m.Attributes {
			_ = k
			_ = v
			l = 0
			if len(v) > 0 {
				l = 1 + len(v) + sovServer(uint64(len(v)))
			}
			mapEntrySize := 1 + sovServer(uint64(k)) + l
			n += mapEntrySize + 1 + sovServer(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetAttributeValueResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Attributes) > 0 {
		for k, v := range m.Attributes {
			_ = k
			_ = v
			l = 0
			if len(v) > 0 {
				l = 1 + len(v) + sovServer(uint64(len(v)))
			}
			mapEntrySize := 1 + sovServer(uint64(k)) + l
			n += mapEntrySize + 1 + sovServer(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SetAttributeValueRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Object)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if len(m.Attributes) > 0 {
		for k, v := range m.Attributes {
			_ = k
			_ = v
			l = 0
			if len(v) > 0 {
				l = 1 + len(v) + sovServer(uint64(len(v)))
			}
			mapEntrySize := 1 + sovServer(uint64(k)) + l
			n += mapEntrySize + 1 + sovServer(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SetAttributeValueResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.Object)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Mechanism) Size() (n int) {
	var l int
	_ = l
	if m.Mechanism != 0 {
		n += 1 + sovServer(uint64(m.Mechanism))
	}
	l = len(m.Parameter)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MechanismInfo) Size() (n int) {
	var l int
	_ = l
	if m.MinKeySize != 0 {
		n += 1 + sovServer(uint64(m.MinKeySize))
	}
	if m.MaxKeySize != 0 {
		n += 1 + sovServer(uint64(m.MaxKeySize))
	}
	if m.Flags != 0 {
		n += 1 + sovServer(uint64(m.Flags))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Grep11Error) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovServer(uint64(m.Code))
	}
	l = len(m.Detail)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.Retry {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovServer(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozServer(x uint64) (n int) {
	return sovServer(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *GenerateRandomRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenerateRandomRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenerateRandomRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Len", wireType)
			}
			m.Len = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Len |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GenerateRandomResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenerateRandomResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenerateRandomResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rnd", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rnd = append(m.Rnd[:0], dAtA[iNdEx:postIndex]...)
			if m.Rnd == nil {
				m.Rnd = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DigestInitRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DigestInitRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DigestInitRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mech", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mech == nil {
				m.Mech = &Mechanism{}
			}
			if err := m.Mech.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DigestInitResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DigestInitResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DigestInitResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = append(m.State[:0], dAtA[iNdEx:postIndex]...)
			if m.State == nil {
				m.State = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DigestRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DigestRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DigestRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = append(m.State[:0], dAtA[iNdEx:postIndex]...)
			if m.State == nil {
				m.State = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DigestResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DigestResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DigestResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Digest", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Digest = append(m.Digest[:0], dAtA[iNdEx:postIndex]...)
			if m.Digest == nil {
				m.Digest = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DigestUpdateRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DigestUpdateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DigestUpdateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = append(m.State[:0], dAtA[iNdEx:postIndex]...)
			if m.State == nil {
				m.State = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DigestUpdateResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DigestUpdateResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DigestUpdateResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = append(m.State[:0], dAtA[iNdEx:postIndex]...)
			if m.State == nil {
				m.State = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DigestKeyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DigestKeyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DigestKeyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = append(m.State[:0], dAtA[iNdEx:postIndex]...)
			if m.State == nil {
				m.State = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DigestKeyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DigestKeyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DigestKeyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = append(m.State[:0], dAtA[iNdEx:postIndex]...)
			if m.State == nil {
				m.State = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DigestFinalRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DigestFinalRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DigestFinalRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = append(m.State[:0], dAtA[iNdEx:postIndex]...)
			if m.State == nil {
				m.State = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DigestFinalResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DigestFinalResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DigestFinalResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Digest", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Digest = append(m.Digest[:0], dAtA[iNdEx:postIndex]...)
			if m.Digest == nil {
				m.Digest = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DigestSingleRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DigestSingleRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DigestSingleRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mech", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mech == nil {
				m.Mech = &Mechanism{}
			}
			if err := m.Mech.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DigestSingleResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DigestSingleResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DigestSingleResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Digest", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Digest = append(m.Digest[:0], dAtA[iNdEx:postIndex]...)
			if m.Digest == nil {
				m.Digest = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncryptInitRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncryptInitRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncryptInitRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mech", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mech == nil {
				m.Mech = &Mechanism{}
			}
			if err := m.Mech.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncryptInitResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncryptInitResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncryptInitResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = append(m.State[:0], dAtA[iNdEx:postIndex]...)
			if m.State == nil {
				m.State = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DecryptInitRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DecryptInitRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DecryptInitRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mech", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mech == nil {
				m.Mech = &Mechanism{}
			}
			if err := m.Mech.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DecryptInitResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DecryptInitResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DecryptInitResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = append(m.State[:0], dAtA[iNdEx:postIndex]...)
			if m.State == nil {
				m.State = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncryptUpdateRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncryptUpdateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncryptUpdateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = append(m.State[:0], dAtA[iNdEx:postIndex]...)
			if m.State == nil {
				m.State = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Plain", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Plain = append(m.Plain[:0], dAtA[iNdEx:postIndex]...)
			if m.Plain == nil {
				m.Plain = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncryptUpdateResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncryptUpdateResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncryptUpdateResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = append(m.State[:0], dAtA[iNdEx:postIndex]...)
			if m.State == nil {
				m.State = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ciphered", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ciphered = append(m.Ciphered[:0], dAtA[iNdEx:postIndex]...)
			if m.Ciphered == nil {
				m.Ciphered = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DecryptUpdateRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DecryptUpdateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DecryptUpdateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = append(m.State[:0], dAtA[iNdEx:postIndex]...)
			if m.State == nil {
				m.State = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ciphered", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ciphered = append(m.Ciphered[:0], dAtA[iNdEx:postIndex]...)
			if m.Ciphered == nil {
				m.Ciphered = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DecryptUpdateResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DecryptUpdateResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DecryptUpdateResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = append(m.State[:0], dAtA[iNdEx:postIndex]...)
			if m.State == nil {
				m.State = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Plain", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Plain = append(m.Plain[:0], dAtA[iNdEx:postIndex]...)
			if m.Plain == nil {
				m.Plain = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncryptRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncryptRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncryptRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = append(m.State[:0], dAtA[iNdEx:postIndex]...)
			if m.State == nil {
				m.State = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Plain", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Plain = append(m.Plain[:0], dAtA[iNdEx:postIndex]...)
			if m.Plain == nil {
				m.Plain = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncryptResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncryptResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncryptResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ciphered", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ciphered = append(m.Ciphered[:0], dAtA[iNdEx:postIndex]...)
			if m.Ciphered == nil {
				m.Ciphered = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DecryptRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DecryptRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DecryptRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = append(m.State[:0], dAtA[iNdEx:postIndex]...)
			if m.State == nil {
				m.State = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ciphered", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ciphered = append(m.Ciphered[:0], dAtA[iNdEx:postIndex]...)
			if m.Ciphered == nil {
				m.Ciphered = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DecryptResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DecryptResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DecryptResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Plain", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Plain = append(m.Plain[:0], dAtA[iNdEx:postIndex]...)
			if m.Plain == nil {
				m.Plain = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncryptFinalRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncryptFinalRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncryptFinalRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = append(m.State[:0], dAtA[iNdEx:postIndex]...)
			if m.State == nil {
				m.State = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncryptFinalResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncryptFinalResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncryptFinalResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ciphered", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ciphered = append(m.Ciphered[:0], dAtA[iNdEx:postIndex]...)
			if m.Ciphered == nil {
				m.Ciphered = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DecryptFinalRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DecryptFinalRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DecryptFinalRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = append(m.State[:0], dAtA[iNdEx:postIndex]...)
			if m.State == nil {
				m.State = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DecryptFinalResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DecryptFinalResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DecryptFinalResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Plain", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Plain = append(m.Plain[:0], dAtA[iNdEx:postIndex]...)
			if m.Plain == nil {
				m.Plain = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncryptSingleRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncryptSingleRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncryptSingleRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mech", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mech == nil {
				m.Mech = &Mechanism{}
			}
			if err := m.Mech.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Plain", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Plain = append(m.Plain[:0], dAtA[iNdEx:postIndex]...)
			if m.Plain == nil {
				m.Plain = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncryptSingleResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncryptSingleResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncryptSingleResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ciphered", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ciphered = append(m.Ciphered[:0], dAtA[iNdEx:postIndex]...)
			if m.Ciphered == nil {
				m.Ciphered = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DecryptSingleRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DecryptSingleRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DecryptSingleRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mech", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mech == nil {
				m.Mech = &Mechanism{}
			}
			if err := m.Mech.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ciphered", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ciphered = append(m.Ciphered[:0], dAtA[iNdEx:postIndex]...)
			if m.Ciphered == nil {
				m.Ciphered = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DecryptSingleResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DecryptSingleResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DecryptSingleResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Plain", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Plain = append(m.Plain[:0], dAtA[iNdEx:postIndex]...)
			if m.Plain == nil {
				m.Plain = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignInitRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignInitRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignInitRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mech", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mech == nil {
				m.Mech = &Mechanism{}
			}
			if err := m.Mech.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivKey = append(m.PrivKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PrivKey == nil {
				m.PrivKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignInitResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignInitResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignInitResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = append(m.State[:0], dAtA[iNdEx:postIndex]...)
			if m.State == nil {
				m.State = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerifyInitRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerifyInitRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerifyInitRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mech", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mech == nil {
				m.Mech = &Mechanism{}
			}
			if err := m.Mech.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubKey = append(m.PubKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PubKey == nil {
				m.PubKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerifyInitResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerifyInitResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerifyInitResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = append(m.State[:0], dAtA[iNdEx:postIndex]...)
			if m.State == nil {
				m.State = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignUpdateRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignUpdateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignUpdateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = append(m.State[:0], dAtA[iNdEx:postIndex]...)
			if m.State == nil {
				m.State = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignUpdateResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignUpdateResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignUpdateResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = append(m.State[:0], dAtA[iNdEx:postIndex]...)
			if m.State == nil {
				m.State = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerifyUpdateRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerifyUpdateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerifyUpdateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = append(m.State[:0], dAtA[iNdEx:postIndex]...)
			if m.State == nil {
				m.State = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerifyUpdateResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerifyUpdateResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerifyUpdateResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = append(m.State[:0], dAtA[iNdEx:postIndex]...)
			if m.State == nil {
				m.State = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignFinalRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignFinalRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignFinalRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = append(m.State[:0], dAtA[iNdEx:postIndex]...)
			if m.State == nil {
				m.State = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignFinalResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignFinalResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignFinalResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerifyFinalRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerifyFinalRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerifyFinalRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = append(m.State[:0], dAtA[iNdEx:postIndex]...)
			if m.State == nil {
				m.State = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerifyFinalResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerifyFinalResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerifyFinalResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = append(m.State[:0], dAtA[iNdEx:postIndex]...)
			if m.State == nil {
				m.State = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerifyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerifyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerifyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = append(m.State[:0], dAtA[iNdEx:postIndex]...)
			if m.State == nil {
				m.State = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerifyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerifyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerifyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignSingleRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignSingleRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignSingleRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivKey = append(m.PrivKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PrivKey == nil {
				m.PrivKey = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mech", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mech == nil {
				m.Mech = &Mechanism{}
			}
			if err := m.Mech.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignSingleResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignSingleResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignSingleResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerifySingleRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerifySingleRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerifySingleRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubKey = append(m.PubKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PubKey == nil {
				m.PubKey = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mech", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mech == nil {
				m.Mech = &Mechanism{}
			}
			if err := m.Mech.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerifySingleResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerifySingleResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerifySingleResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GenerateKeyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenerateKeyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenerateKeyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mech", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mech == nil {
				m.Mech = &Mechanism{}
			}
			if err := m.Mech.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Template", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Template == nil {
				m.Template = make(map[github_com_ibm_developer_ibm_cloud_hyperprotectcrypto_golang_ep11.Attribute][]byte)
			}
			var mapkey uint64
			mapvalue := []byte{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapbyteLen uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapbyteLen |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intMapbyteLen := int(mapbyteLen)
					if intMapbyteLen < 0 {
						return ErrInvalidLengthServer
					}
					postbytesIndex := iNdEx + intMapbyteLen
					if postbytesIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = make([]byte, mapbyteLen)
					copy(mapvalue, dAtA[iNdEx:postbytesIndex])
					iNdEx = postbytesIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipServer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthServer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Template[github_com_ibm_developer_ibm_cloud_hyperprotectcrypto_golang_ep11.Attribute(mapkey)] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GenerateKeyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenerateKeyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenerateKeyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckSum", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CheckSum = append(m.CheckSum[:0], dAtA[iNdEx:postIndex]...)
			if m.CheckSum == nil {
				m.CheckSum = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GenerateKeyPairRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenerateKeyPairRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenerateKeyPairRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mech", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mech == nil {
				m.Mech = &Mechanism{}
			}
			if err := m.Mech.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKeyTemplate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PubKeyTemplate == nil {
				m.PubKeyTemplate = make(map[github_com_ibm_developer_ibm_cloud_hyperprotectcrypto_golang_ep11.Attribute][]byte)
			}
			var mapkey uint64
			mapvalue := []byte{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapbyteLen uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapbyteLen |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intMapbyteLen := int(mapbyteLen)
					if intMapbyteLen < 0 {
						return ErrInvalidLengthServer
					}
					postbytesIndex := iNdEx + intMapbyteLen
					if postbytesIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = make([]byte, mapbyteLen)
					copy(mapvalue, dAtA[iNdEx:postbytesIndex])
					iNdEx = postbytesIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipServer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthServer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.PubKeyTemplate[github_com_ibm_developer_ibm_cloud_hyperprotectcrypto_golang_ep11.Attribute(mapkey)] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivKeyTemplate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PrivKeyTemplate == nil {
				m.PrivKeyTemplate = make(map[github_com_ibm_developer_ibm_cloud_hyperprotectcrypto_golang_ep11.Attribute][]byte)
			}
			var mapkey uint64
			mapvalue := []byte{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapbyteLen uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapbyteLen |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intMapbyteLen := int(mapbyteLen)
					if intMapbyteLen < 0 {
						return ErrInvalidLengthServer
					}
					postbytesIndex := iNdEx + intMapbyteLen
					if postbytesIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = make([]byte, mapbyteLen)
					copy(mapvalue, dAtA[iNdEx:postbytesIndex])
					iNdEx = postbytesIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipServer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthServer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.PrivKeyTemplate[github_com_ibm_developer_ibm_cloud_hyperprotectcrypto_golang_ep11.Attribute(mapkey)] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivKeyId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivKeyId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKeyId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubKeyId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GenerateKeyPairResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenerateKeyPairResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenerateKeyPairResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivKey = append(m.PrivKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PrivKey == nil {
				m.PrivKey = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubKey = append(m.PubKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PubKey == nil {
				m.PubKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WrapKeyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WrapKeyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WrapKeyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeK", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeK = append(m.KeK[:0], dAtA[iNdEx:postIndex]...)
			if m.KeK == nil {
				m.KeK = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MacKey = append(m.MacKey[:0], dAtA[iNdEx:postIndex]...)
			if m.MacKey == nil {
				m.MacKey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mech", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mech == nil {
				m.Mech = &Mechanism{}
			}
			if err := m.Mech.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WrapKeyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WrapKeyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WrapKeyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wrapped", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Wrapped = append(m.Wrapped[:0], dAtA[iNdEx:postIndex]...)
			if m.Wrapped == nil {
				m.Wrapped = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnwrapKeyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnwrapKeyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnwrapKeyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wrapped", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Wrapped = append(m.Wrapped[:0], dAtA[iNdEx:postIndex]...)
			if m.Wrapped == nil {
				m.Wrapped = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeK", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeK = append(m.KeK[:0], dAtA[iNdEx:postIndex]...)
			if m.KeK == nil {
				m.KeK = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MacKey = append(m.MacKey[:0], dAtA[iNdEx:postIndex]...)
			if m.MacKey == nil {
				m.MacKey = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mech", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mech == nil {
				m.Mech = &Mechanism{}
			}
			if err := m.Mech.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Template", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Template == nil {
				m.Template = make(map[github_com_ibm_developer_ibm_cloud_hyperprotectcrypto_golang_ep11.Attribute][]byte)
			}
			var mapkey uint64
			mapvalue := []byte{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapbyteLen uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapbyteLen |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intMapbyteLen := int(mapbyteLen)
					if intMapbyteLen < 0 {
						return ErrInvalidLengthServer
					}
					postbytesIndex := iNdEx + intMapbyteLen
					if postbytesIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = make([]byte, mapbyteLen)
					copy(mapvalue, dAtA[iNdEx:postbytesIndex])
					iNdEx = postbytesIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipServer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthServer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Template[github_com_ibm_developer_ibm_cloud_hyperprotectcrypto_golang_ep11.Attribute(mapkey)] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnwrappedId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UnwrappedId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnwrapKeyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnwrapKeyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnwrapKeyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unwrapped", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Unwrapped = append(m.Unwrapped[:0], dAtA[iNdEx:postIndex]...)
			if m.Unwrapped == nil {
				m.Unwrapped = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckSum", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CheckSum = append(m.CheckSum[:0], dAtA[iNdEx:postIndex]...)
			if m.CheckSum == nil {
				m.CheckSum = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeriveKeyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeriveKeyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeriveKeyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mech", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mech == nil {
				m.Mech = &Mechanism{}
			}
			if err := m.Mech.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Template", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Template == nil {
				m.Template = make(map[github_com_ibm_developer_ibm_cloud_hyperprotectcrypto_golang_ep11.Attribute][]byte)
			}
			var mapkey uint64
			mapvalue := []byte{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapbyteLen uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapbyteLen |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intMapbyteLen := int(mapbyteLen)
					if intMapbyteLen < 0 {
						return ErrInvalidLengthServer
					}
					postbytesIndex := iNdEx + intMapbyteLen
					if postbytesIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = make([]byte, mapbyteLen)
					copy(mapvalue, dAtA[iNdEx:postbytesIndex])
					iNdEx = postbytesIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipServer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthServer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Template[github_com_ibm_developer_ibm_cloud_hyperprotectcrypto_golang_ep11.Attribute(mapkey)] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BaseKey = append(m.BaseKey[:0], dAtA[iNdEx:postIndex]...)
			if m.BaseKey == nil {
				m.BaseKey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewKeyId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewKeyId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeriveKeyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeriveKeyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeriveKeyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewKey = append(m.NewKey[:0], dAtA[iNdEx:postIndex]...)
			if m.NewKey == nil {
				m.NewKey = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckSum", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CheckSum = append(m.CheckSum[:0], dAtA[iNdEx:postIndex]...)
			if m.CheckSum == nil {
				m.CheckSum = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetMechanismListRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetMechanismListRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetMechanismListRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetMechanismListResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetMechanismListResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetMechanismListResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType == 0 {
				var v github_com_ibm_developer_ibm_cloud_hyperprotectcrypto_golang_ep11.Mechanism
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (github_com_ibm_developer_ibm_cloud_hyperprotectcrypto_golang_ep11.Mechanism(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Mechs = append(m.Mechs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServer
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v github_com_ibm_developer_ibm_cloud_hyperprotectcrypto_golang_ep11.Mechanism
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (github_com_ibm_developer_ibm_cloud_hyperprotectcrypto_golang_ep11.Mechanism(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Mechs = append(m.Mechs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Mechs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetMechanismInfoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetMechanismInfoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetMechanismInfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mech", wireType)
			}
			m.Mech = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mech |= (github_com_ibm_developer_ibm_cloud_hyperprotectcrypto_golang_ep11.Mechanism(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetMechanismInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetMechanismInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetMechanismInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MechInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MechInfo == nil {
				m.MechInfo = &MechanismInfo{}
			}
			if err := m.MechInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAttributeValueRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAttributeValueRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAttributeValueRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Object", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Object = append(m.Object[:0], dAtA[iNdEx:postIndex]...)
			if m.Object == nil {
				m.Object = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Attributes == nil {
				m.Attributes = make(map[github_com_ibm_developer_ibm_cloud_hyperprotectcrypto_golang_ep11.Attribute][]byte)
			}
			var mapkey uint64
			mapvalue := []byte{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapbyteLen uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapbyteLen |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intMapbyteLen := int(mapbyteLen)
					if intMapbyteLen < 0 {
						return ErrInvalidLengthServer
					}
					postbytesIndex := iNdEx + intMapbyteLen
					if postbytesIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = make([]byte, mapbyteLen)
					copy(mapvalue, dAtA[iNdEx:postbytesIndex])
					iNdEx = postbytesIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipServer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthServer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Attributes[github_com_ibm_developer_ibm_cloud_hyperprotectcrypto_golang_ep11.Attribute(mapkey)] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAttributeValueResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAttributeValueResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAttributeValueResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Attributes == nil {
				m.Attributes = make(map[github_com_ibm_developer_ibm_cloud_hyperprotectcrypto_golang_ep11.Attribute][]byte)
			}
			var mapkey uint64
			mapvalue := []byte{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapbyteLen uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapbyteLen |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intMapbyteLen := int(mapbyteLen)
					if intMapbyteLen < 0 {
						return ErrInvalidLengthServer
					}
					postbytesIndex := iNdEx + intMapbyteLen
					if postbytesIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = make([]byte, mapbyteLen)
					copy(mapvalue, dAtA[iNdEx:postbytesIndex])
					iNdEx = postbytesIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipServer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthServer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Attributes[github_com_ibm_developer_ibm_cloud_hyperprotectcrypto_golang_ep11.Attribute(mapkey)] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetAttributeValueRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetAttributeValueRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetAttributeValueRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Object", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Object = append(m.Object[:0], dAtA[iNdEx:postIndex]...)
			if m.Object == nil {
				m.Object = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Attributes == nil {
				m.Attributes = make(map[github_com_ibm_developer_ibm_cloud_hyperprotectcrypto_golang_ep11.Attribute][]byte)
			}
			var mapkey uint64
			mapvalue := []byte{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapbyteLen uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapbyteLen |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intMapbyteLen := int(mapbyteLen)
					if intMapbyteLen < 0 {
						return ErrInvalidLengthServer
					}
					postbytesIndex := iNdEx + intMapbyteLen
					if postbytesIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = make([]byte, mapbyteLen)
					copy(mapvalue, dAtA[iNdEx:postbytesIndex])
					iNdEx = postbytesIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipServer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthServer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Attributes[github_com_ibm_developer_ibm_cloud_hyperprotectcrypto_golang_ep11.Attribute(mapkey)] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetAttributeValueResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetAttributeValueResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetAttributeValueResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Object", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Object = append(m.Object[:0], dAtA[iNdEx:postIndex]...)
			if m.Object == nil {
				m.Object = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Mechanism) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Mechanism: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Mechanism: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mechanism", wireType)
			}
			m.Mechanism = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mechanism |= (github_com_ibm_developer_ibm_cloud_hyperprotectcrypto_golang_ep11.Mechanism(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parameter", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parameter = append(m.Parameter[:0], dAtA[iNdEx:postIndex]...)
			if m.Parameter == nil {
				m.Parameter = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MechanismInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MechanismInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MechanismInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinKeySize", wireType)
			}
			m.MinKeySize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinKeySize |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxKeySize", wireType)
			}
			m.MaxKeySize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxKeySize |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Grep11Error) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Grep11Error: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Grep11Error: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (github_com_ibm_developer_ibm_cloud_hyperprotectcrypto_golang_ep11.Return(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Detail", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Detail = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Retry", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Retry = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipServer(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowServer
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowServer
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowServer
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthServer
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowServer
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipServer(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthServer = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowServer   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("server.proto", fileDescriptor_server_6ab464f07e1d7a68) }

var fileDescriptor_server_6ab464f07e1d7a68 = []byte{
	// 2327 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x5a, 0x4b, 0x6f, 0x1c, 0xc7,
	0x11, 0xc6, 0x2c, 0x97, 0x14, 0x59, 0x7c, 0x0f, 0x1f, 0x5a, 0x8e, 0x28, 0x92, 0xea, 0xc4, 0x36,
	0x2d, 0x9b, 0x64, 0x48, 0x1d, 0x92, 0x28, 0x31, 0x0c, 0x93, 0x92, 0x25, 0x62, 0xc5, 0x88, 0x98,
	0x8d, 0x6c, 0xe4, 0x10, 0x20, 0x43, 0x6e, 0x7b, 0x39, 0xd1, 0x72, 0x76, 0x35, 0x3b, 0x4b, 0x67,
	0x03, 0x24, 0x80, 0x7d, 0xc8, 0x0f, 0x88, 0x60, 0x20, 0x97, 0x1c, 0x92, 0x43, 0x2e, 0x01, 0xf2,
	0x3b, 0x72, 0x0c, 0x10, 0x20, 0x47, 0x3b, 0x10, 0xf2, 0x0b, 0x72, 0xf4, 0x25, 0x41, 0xbf, 0x1f,
	0xd3, 0x9c, 0x5d, 0x3e, 0x64, 0x20, 0xb9, 0x6d, 0x77, 0x57, 0xd7, 0x57, 0x55, 0x5d, 0xd5, 0xd5,
	0x53, 0xb5, 0x30, 0xd1, 0xc1, 0xe9, 0x19, 0x4e, 0x37, 0xdb, 0x69, 0x2b, 0x6b, 0xf9, 0x23, 0x8d,
	0x14, 0xb7, 0xb7, 0xb7, 0x03, 0x68, 0xb4, 0x1a, 0x2d, 0x36, 0x17, 0x2c, 0x37, 0x5a, 0xad, 0x46,
	0x13, 0x6f, 0x45, 0xed, 0x78, 0x2b, 0x4a, 0x92, 0x56, 0x16, 0x65, 0x71, 0x2b, 0xe9, 0xb0, 0x55,
	0xf4, 0x36, 0x2c, 0x3c, 0xc2, 0x09, 0x4e, 0xa3, 0x0c, 0x87, 0x51, 0x52, 0x6f, 0x9d, 0x86, 0xf8,
	0x45, 0x17, 0x77, 0x32, 0x7f, 0x06, 0x86, 0x9e, 0xe0, 0xa4, 0xe2, 0xad, 0x79, 0xeb, 0xe5, 0x90,
	0xfc, 0x44, 0x77, 0x61, 0xd1, 0x26, 0xed, 0xb4, 0x5b, 0x49, 0x07, 0x13, 0xda, 0x30, 0xa9, 0x53,
	0xda, 0x89, 0x90, 0xfc, 0x44, 0xf7, 0x61, 0xf6, 0x41, 0xdc, 0xc0, 0x9d, 0x6c, 0x3f, 0x89, 0x33,
	0xc1, 0xf2, 0x0d, 0x28, 0x1f, 0xe0, 0xe3, 0x93, 0x4a, 0x69, 0xcd, 0x5b, 0x1f, 0xdf, 0x99, 0xdd,
	0x64, 0xc2, 0x6e, 0x92, 0xb9, 0x28, 0x89, 0x3b, 0xa7, 0x21, 0x5d, 0x46, 0x77, 0xc1, 0xd7, 0xf7,
	0x72, 0x8c, 0x79, 0x18, 0xae, 0x65, 0x51, 0x86, 0x39, 0x0a, 0x1b, 0xa0, 0xef, 0xc3, 0x24, 0xa3,
	0x15, 0x18, 0x4e, 0x32, 0xdf, 0x87, 0xf2, 0x83, 0x28, 0x8b, 0x28, 0xf2, 0x44, 0x48, 0x7f, 0xa3,
	0x75, 0x98, 0x12, 0x5b, 0x39, 0xc4, 0x22, 0x8c, 0xb0, 0x99, 0xca, 0x10, 0xa5, 0xe3, 0x23, 0xf4,
	0x3e, 0xcc, 0xb1, 0x5f, 0xcf, 0xda, 0x75, 0xa2, 0xfc, 0x85, 0xa1, 0xde, 0x85, 0x79, 0x93, 0x41,
	0xa1, 0x4e, 0xf7, 0x61, 0x86, 0x51, 0x57, 0x71, 0xaf, 0x18, 0x6b, 0x06, 0x86, 0xaa, 0xb8, 0xc7,
	0xa1, 0xc8, 0x4f, 0xf4, 0xb6, 0xb0, 0x3b, 0xdd, 0x5b, 0x08, 0x23, 0xcd, 0xfc, 0x61, 0x9c, 0x44,
	0xcd, 0x42, 0x20, 0xb4, 0x21, 0x2c, 0xc0, 0x69, 0x73, 0x06, 0x2b, 0x19, 0x06, 0x3b, 0x14, 0xe4,
	0xb5, 0x38, 0x69, 0x34, 0xb1, 0x7d, 0xfe, 0x5e, 0xe1, 0xf9, 0x3b, 0x2d, 0xb8, 0x29, 0x2c, 0x28,
	0x38, 0xf6, 0x39, 0xb2, 0x03, 0xf0, 0x1f, 0x26, 0xc7, 0x69, 0xaf, 0x7d, 0x09, 0x07, 0x14, 0x66,
	0x1d, 0x52, 0x66, 0x7d, 0x07, 0xe6, 0x0c, 0x76, 0x85, 0x86, 0x3d, 0x00, 0xff, 0x01, 0xbe, 0x56,
	0x6c, 0x83, 0x5d, 0x21, 0xf6, 0x2e, 0xcc, 0x73, 0x41, 0x07, 0xf1, 0xd5, 0x79, 0x18, 0x3e, 0x6c,
	0x46, 0x71, 0xc2, 0x4d, 0xcd, 0x06, 0x68, 0x1f, 0x16, 0x2c, 0x1e, 0x45, 0x90, 0x7e, 0x00, 0xa3,
	0x7b, 0x71, 0xfb, 0x04, 0xa7, 0xb8, 0xce, 0xc5, 0x96, 0x63, 0xf4, 0x18, 0xe6, 0xb9, 0xec, 0x83,
	0x88, 0xa3, 0x73, 0x2a, 0x59, 0x9c, 0xf6, 0x60, 0xc1, 0xe2, 0x54, 0x28, 0x94, 0xd4, 0x6c, 0x48,
	0xd7, 0xec, 0x87, 0x30, 0xc5, 0x35, 0xbb, 0x8c, 0x5d, 0x36, 0x60, 0x5a, 0xee, 0xe6, 0xe0, 0x45,
	0xba, 0xef, 0xc2, 0x14, 0x97, 0xf8, 0xf2, 0x5a, 0xbf, 0x05, 0xd3, 0x92, 0x87, 0xd2, 0xd7, 0xa1,
	0x99, 0x72, 0xd0, 0x01, 0xa2, 0x79, 0x47, 0x3a, 0x89, 0x19, 0xce, 0x45, 0x92, 0x28, 0x2f, 0x1c,
	0x00, 0xe0, 0x5d, 0x79, 0xec, 0x26, 0x80, 0xdb, 0xae, 0x58, 0x8a, 0x63, 0x5e, 0x17, 0x3c, 0x14,
	0x3c, 0x19, 0x0a, 0x83, 0xc6, 0x90, 0xdb, 0x44, 0xf7, 0xa4, 0x5b, 0x5b, 0x77, 0x88, 0xae, 0x76,
	0xd9, 0x52, 0xfb, 0xb9, 0xd4, 0xe4, 0x9a, 0x64, 0x2b, 0xf2, 0x98, 0x0d, 0xe9, 0xe3, 0x96, 0x84,
	0x52, 0xa1, 0xb2, 0xae, 0x50, 0x08, 0xd3, 0xb5, 0xb8, 0x91, 0x5c, 0xe2, 0x92, 0xa9, 0xc0, 0x8d,
	0xc3, 0x34, 0x3e, 0x53, 0x17, 0x8d, 0x18, 0xa2, 0x75, 0x98, 0x51, 0x3c, 0x0b, 0x6f, 0x9a, 0x10,
	0x66, 0x3f, 0xc2, 0x69, 0xfc, 0x49, 0xef, 0x12, 0xf8, 0x8b, 0x30, 0x72, 0xd8, 0x3d, 0x52, 0xf0,
	0x7c, 0x44, 0x52, 0x92, 0xce, 0xb3, 0x10, 0xff, 0x3d, 0x98, 0x25, 0x92, 0x5e, 0x36, 0x25, 0xdf,
	0x05, 0x5f, 0xdf, 0x5e, 0x08, 0xf5, 0x3e, 0xcc, 0x31, 0xb1, 0xae, 0x90, 0xff, 0x4d, 0x06, 0x85,
	0x70, 0xfc, 0x0c, 0x06, 0x88, 0xb3, 0x6d, 0x66, 0x03, 0x33, 0xc8, 0x96, 0x61, 0x8c, 0x4c, 0x46,
	0x59, 0x37, 0xc5, 0x5c, 0x0a, 0x35, 0x81, 0x1e, 0x0b, 0x13, 0xf7, 0x67, 0xdf, 0x87, 0xd3, 0x82,
	0xb0, 0x8a, 0x01, 0x8f, 0xbe, 0x0b, 0xe3, 0x84, 0xe6, 0x32, 0x46, 0x9a, 0x60, 0x1b, 0x5d, 0x7a,
	0x0c, 0xd9, 0xe8, 0x1f, 0xc3, 0x24, 0x43, 0xbf, 0x30, 0x50, 0x1f, 0xc6, 0x33, 0x30, 0x25, 0x18,
	0x73, 0x8d, 0x4e, 0x98, 0x95, 0xcd, 0x0b, 0x40, 0x0b, 0x21, 0xcf, 0x08, 0xa1, 0x41, 0x63, 0x40,
	0x48, 0x36, 0xa4, 0x99, 0x60, 0x87, 0x39, 0xa5, 0x15, 0xfd, 0x86, 0xbc, 0x65, 0x5b, 0xde, 0xdf,
	0x78, 0xe2, 0x1c, 0x4c, 0x01, 0x55, 0x8c, 0x79, 0x7a, 0x8c, 0x5d, 0x41, 0xbc, 0x3e, 0x82, 0x2c,
	0x0a, 0x27, 0x37, 0xc5, 0x47, 0x7f, 0x2a, 0x81, 0x2f, 0xbe, 0x1b, 0xb4, 0x17, 0xed, 0x80, 0x8f,
	0xc1, 0x2f, 0x3c, 0x18, 0xfd, 0x31, 0x3e, 0x6d, 0x37, 0xc9, 0xd1, 0x96, 0xd6, 0x86, 0xd6, 0xc7,
	0x77, 0xd6, 0x05, 0x6d, 0x9e, 0xeb, 0xa6, 0x20, 0x7d, 0x98, 0x64, 0x69, 0x6f, 0xf7, 0xe9, 0xe7,
	0x5f, 0xad, 0x56, 0x1b, 0x71, 0x76, 0xd2, 0x3d, 0xda, 0x3c, 0x6e, 0x9d, 0x6e, 0xc5, 0x47, 0xa7,
	0x1b, 0x75, 0x7c, 0x86, 0x9b, 0xad, 0x36, 0x4e, 0xe9, 0xe8, 0xb8, 0xd9, 0xea, 0xd6, 0x37, 0x4e,
	0x7a, 0x6d, 0x9c, 0x92, 0xef, 0x21, 0x7c, 0x9c, 0xd1, 0xfb, 0xb7, 0xb5, 0xd5, 0x68, 0x35, 0xa3,
	0xa4, 0xb1, 0x45, 0x71, 0x3e, 0xc8, 0xb2, 0x34, 0x3e, 0xea, 0x66, 0x38, 0x94, 0xa2, 0x10, 0x77,
	0xab, 0xe2, 0xde, 0x3e, 0xcb, 0x18, 0x63, 0x21, 0x1b, 0x04, 0x3f, 0x80, 0x49, 0x43, 0x02, 0x92,
	0x27, 0x9e, 0xf3, 0x23, 0x28, 0x87, 0xe4, 0x27, 0xd9, 0x78, 0x16, 0x35, 0xbb, 0x22, 0xa0, 0xd8,
	0xe0, 0x7e, 0xe9, 0x7b, 0x1e, 0xda, 0x83, 0x39, 0x43, 0x23, 0xf5, 0x71, 0x45, 0x4e, 0xb1, 0xac,
	0x52, 0x0d, 0xc9, 0x21, 0x27, 0xf8, 0xf8, 0x79, 0xad, 0x7b, 0x5a, 0x19, 0xe6, 0x39, 0x84, 0x8f,
	0xd1, 0x57, 0x65, 0xf5, 0x95, 0x56, 0xc5, 0xbd, 0xc3, 0x28, 0x4e, 0x2f, 0x68, 0xf1, 0x3f, 0x7b,
	0x30, 0xc5, 0x7c, 0xc5, 0xb2, 0xfb, 0x8e, 0xc3, 0xee, 0x1a, 0xff, 0x4d, 0x73, 0xd3, 0x6b, 0x3a,
	0x01, 0x4b, 0x34, 0xff, 0x2f, 0x1e, 0x4c, 0xf3, 0xc8, 0x93, 0xe2, 0x0e, 0x51, 0x71, 0xef, 0xf5,
	0x13, 0xd7, 0xdc, 0xf5, 0x9a, 0xe4, 0xb5, 0x85, 0x23, 0x41, 0xc4, 0xa7, 0xf6, 0xeb, 0xf4, 0xf4,
	0xc6, 0x42, 0x35, 0x41, 0x8e, 0x96, 0x29, 0xb8, 0x5f, 0xaf, 0x8c, 0xd0, 0x45, 0x39, 0x0e, 0x3e,
	0x80, 0x39, 0x87, 0x89, 0x2f, 0xe2, 0x62, 0xc1, 0x2e, 0xcc, 0xbb, 0xd4, 0xbe, 0x90, 0x9b, 0x56,
	0xe1, 0x66, 0xce, 0xa2, 0xdc, 0x55, 0xb5, 0x4b, 0x71, 0xd8, 0xbc, 0x14, 0xd5, 0x6d, 0x34, 0x62,
	0x64, 0xfc, 0x0e, 0x4c, 0x7d, 0x9c, 0x46, 0x6d, 0xed, 0x5e, 0xc8, 0xbf, 0xac, 0xe8, 0x4c, 0x55,
	0x7d, 0xe5, 0x56, 0x09, 0xb7, 0x83, 0xe8, 0x58, 0x7b, 0x3f, 0xb0, 0x91, 0xf4, 0xf0, 0x72, 0x71,
	0x81, 0xe1, 0x1d, 0x98, 0x96, 0xa0, 0x4a, 0x72, 0x32, 0xd5, 0xc6, 0x75, 0x21, 0x39, 0x1f, 0xa2,
	0x7f, 0x97, 0x60, 0xe6, 0x59, 0xf2, 0xa9, 0x29, 0xa4, 0x46, 0xee, 0x19, 0xe4, 0x97, 0x10, 0x76,
	0xb8, 0x38, 0x1c, 0x5f, 0xea, 0x17, 0xe0, 0x08, 0xf5, 0xec, 0x37, 0x05, 0xad, 0x2d, 0xd7, 0x37,
	0x77, 0xfd, 0xad, 0xc1, 0x38, 0x03, 0x6f, 0xe3, 0xfa, 0x7e, 0xbd, 0x72, 0x83, 0xba, 0xaa, 0x3e,
	0x75, 0xb5, 0xab, 0xf0, 0x00, 0x66, 0x35, 0xdd, 0x54, 0x1e, 0x94, 0x00, 0x14, 0x71, 0x22, 0x54,
	0x13, 0xc6, 0xa5, 0x38, 0x6a, 0x5d, 0x8a, 0xff, 0x28, 0xc1, 0xcc, 0x03, 0x9c, 0xc6, 0x67, 0x97,
	0x48, 0x40, 0x2f, 0xf3, 0x09, 0x48, 0xda, 0xdf, 0xe6, 0xf9, 0xcd, 0xd9, 0xbf, 0x02, 0x37, 0x76,
	0xa3, 0x0e, 0xd6, 0x5e, 0xf0, 0x7c, 0x28, 0x13, 0x77, 0x59, 0x4b, 0xdc, 0x01, 0x8c, 0xfe, 0x08,
	0x7f, 0x6a, 0xdc, 0x2a, 0x62, 0x7c, 0xb5, 0x73, 0x7a, 0x04, 0xb3, 0x9a, 0x0d, 0x54, 0x4d, 0x86,
	0x71, 0x17, 0xb1, 0xce, 0x46, 0xc6, 0x09, 0xdd, 0xb0, 0x4e, 0x68, 0x89, 0x5c, 0x2a, 0x99, 0xb4,
	0xfd, 0x93, 0x58, 0x56, 0xf4, 0xd0, 0x67, 0x1e, 0x54, 0xf2, 0x6b, 0x1c, 0x0b, 0xc3, 0x30, 0x59,
	0xe8, 0xd0, 0x93, 0x29, 0xef, 0x3e, 0xfd, 0xfa, 0xcb, 0xeb, 0xb0, 0xb8, 0xf2, 0x01, 0xc6, 0x1d,
	0xfd, 0xda, 0x14, 0x6f, 0x3f, 0xf9, 0xa4, 0x25, 0xdc, 0xe8, 0x58, 0x7b, 0x4f, 0xbd, 0x06, 0x01,
	0xd8, 0x8d, 0x75, 0x60, 0x9a, 0x80, 0xe1, 0x73, 0x13, 0x6c, 0xc3, 0x28, 0x59, 0x20, 0x73, 0xd4,
	0x17, 0xc6, 0x77, 0x16, 0x72, 0xbe, 0x4c, 0x37, 0x48, 0x32, 0xf4, 0x45, 0x89, 0xf2, 0x93, 0x8e,
	0xf5, 0x11, 0x39, 0x50, 0xed, 0xe1, 0xf8, 0xf4, 0xe8, 0xe7, 0xf8, 0x38, 0x13, 0x0f, 0x47, 0x36,
	0xf2, 0xff, 0xe0, 0x01, 0xc8, 0x1d, 0x1d, 0x1e, 0x0a, 0xdf, 0x51, 0x49, 0xd6, 0xcd, 0x4e, 0x79,
	0x6f, 0xe7, 0x35, 0x05, 0x85, 0x26, 0x54, 0xf0, 0x1e, 0x4c, 0x5b, 0x78, 0x17, 0x72, 0xe7, 0xff,
	0x78, 0xb0, 0xe4, 0x50, 0x84, 0x1b, 0xfa, 0x8f, 0x2e, 0x03, 0x6c, 0x17, 0x18, 0x80, 0xed, 0xfb,
	0x9f, 0xb2, 0x00, 0xf1, 0x8c, 0xda, 0xf5, 0x7a, 0x46, 0xed, 0xff, 0xc1, 0x33, 0xee, 0xc1, 0x52,
	0xed, 0x5c, 0xc7, 0x38, 0xc7, 0x2e, 0xe8, 0x77, 0x1e, 0x8c, 0xc9, 0x10, 0xf4, 0x4f, 0xb5, 0x01,
	0x03, 0xbd, 0xfe, 0xdb, 0x42, 0x83, 0x23, 0xef, 0xcc, 0x28, 0x8d, 0x4e, 0x71, 0x86, 0x53, 0xf1,
	0xf1, 0x2e, 0x27, 0x10, 0x86, 0x49, 0xe3, 0x72, 0xf0, 0x57, 0x00, 0x0e, 0xe2, 0xa4, 0x8a, 0x7b,
	0xb5, 0xf8, 0x97, 0x98, 0xdb, 0x44, 0x9b, 0xa1, 0xeb, 0xd1, 0x2f, 0xc4, 0x7a, 0x89, 0xaf, 0xcb,
	0x19, 0x62, 0xba, 0x0f, 0x9b, 0x51, 0xa3, 0x43, 0xaf, 0xa0, 0x72, 0xc8, 0x06, 0xe8, 0xf7, 0x1e,
	0x8c, 0x3f, 0xa2, 0x6e, 0xf0, 0x30, 0x4d, 0x5b, 0xa9, 0xff, 0x33, 0x28, 0xef, 0xb5, 0xea, 0x9c,
	0xff, 0xee, 0x93, 0xaf, 0xbf, 0x5c, 0x7d, 0x7c, 0x75, 0xf5, 0x43, 0x9c, 0x75, 0xd3, 0x24, 0xa4,
	0x9c, 0x69, 0x43, 0x00, 0x67, 0x51, 0xdc, 0xa4, 0x32, 0x8e, 0x85, 0x7c, 0x44, 0xe4, 0x0b, 0x71,
	0x96, 0xb2, 0x74, 0x39, 0x1a, 0xb2, 0xc1, 0xce, 0x6f, 0x57, 0x60, 0x64, 0x8f, 0x72, 0xf4, 0xbb,
	0x30, 0x65, 0x76, 0xb7, 0xfc, 0xdb, 0xf6, 0x07, 0x84, 0xd1, 0x20, 0x0b, 0x56, 0xce, 0x5b, 0xe6,
	0xdf, 0xbd, 0xdf, 0xfe, 0xfc, 0xef, 0xff, 0x7a, 0x59, 0x5a, 0x41, 0x4b, 0x5b, 0x67, 0xdb, 0x5b,
	0x5c, 0x6c, 0x93, 0xf4, 0xbe, 0x77, 0xd7, 0xc7, 0x00, 0xaa, 0xd9, 0xe5, 0x2f, 0xc9, 0x97, 0x85,
	0xdd, 0x3c, 0x0b, 0x02, 0xd7, 0x12, 0x87, 0x5a, 0xa3, 0x50, 0x01, 0x5a, 0xd0, 0xa0, 0x14, 0x19,
	0x81, 0x79, 0x26, 0xfa, 0x24, 0xfe, 0x82, 0xc9, 0x47, 0xb0, 0x5f, 0xb4, 0xa7, 0x39, 0xeb, 0x65,
	0xca, 0x7a, 0x11, 0xcd, 0xe6, 0x58, 0x13, 0xb6, 0xa7, 0x30, 0xa1, 0x37, 0xb6, 0xfc, 0x5b, 0x26,
	0x17, 0xa3, 0x5e, 0x16, 0x2c, 0xbb, 0x17, 0x39, 0x10, 0xa2, 0x40, 0xcb, 0xe8, 0x66, 0x0e, 0x88,
	0x11, 0x12, 0xb8, 0x08, 0xc6, 0x64, 0x77, 0xcb, 0xaf, 0x98, 0xec, 0xd4, 0x2b, 0x2c, 0x58, 0x72,
	0xac, 0x70, 0x94, 0x55, 0x8a, 0xb2, 0x84, 0xe6, 0x73, 0x28, 0x55, 0xdc, 0x23, 0x10, 0x31, 0x8c,
	0x6b, 0x9d, 0x2e, 0xdf, 0xb2, 0xba, 0x5e, 0x34, 0x0b, 0x6e, 0x39, 0xd7, 0x38, 0xd0, 0x1d, 0x0a,
	0x74, 0x0b, 0x2d, 0xe6, 0x80, 0x28, 0x9d, 0x61, 0x3c, 0x56, 0x30, 0xb1, 0x8d, 0x67, 0x94, 0x73,
	0x6c, 0xe3, 0x59, 0x35, 0x96, 0xf3, 0x8d, 0xc7, 0x08, 0xb9, 0x66, 0x5a, 0x0f, 0x4b, 0x69, 0x96,
	0xef, 0x93, 0x29, 0xcd, 0x1c, 0x4d, 0x2f, 0xa7, 0x66, 0x1a, 0x9d, 0x30, 0x22, 0x76, 0x40, 0xe5,
	0xdb, 0x62, 0x9a, 0x11, 0xf1, 0x60, 0x50, 0x1a, 0x1d, 0x81, 0x7a, 0x01, 0x93, 0x46, 0xb3, 0xca,
	0x5f, 0xb6, 0x64, 0x37, 0x7d, 0xf0, 0xf6, 0x39, 0xab, 0x1c, 0xf0, 0x5b, 0x14, 0xf0, 0x36, 0xaa,
	0xe4, 0x75, 0x53, 0x5e, 0xf8, 0x02, 0x26, 0x8d, 0x56, 0x94, 0x82, 0x74, 0xf5, 0xba, 0x14, 0xa4,
	0xb3, 0x7f, 0xe5, 0x84, 0x34, 0x28, 0x09, 0xe4, 0x4f, 0xe0, 0x06, 0x17, 0xc3, 0x5f, 0xb4, 0x34,
	0x10, 0x30, 0x37, 0x73, 0xf3, 0x1c, 0xe0, 0x36, 0x05, 0xb8, 0x89, 0xfc, 0xbc, 0x4e, 0x9c, 0x35,
	0x87, 0x53, 0xac, 0xcd, 0xbe, 0x95, 0x62, 0x6d, 0xf5, 0xa2, 0x9c, 0xac, 0x39, 0x0d, 0x77, 0x70,
	0xbd, 0xcf, 0xe4, 0xdb, 0x6e, 0x65, 0x44, 0xd3, 0xb2, 0x7b, 0xb1, 0xc0, 0xc1, 0x75, 0x42, 0x11,
	0x4f, 0xd8, 0x05, 0xe7, 0x68, 0x5c, 0x05, 0xcb, 0xee, 0xc5, 0xa2, 0x78, 0xc2, 0x26, 0x9c, 0xf2,
	0x3c, 0x1e, 0xbf, 0xb6, 0x06, 0x66, 0x00, 0xdf, 0x3e, 0x67, 0xb5, 0xbf, 0xe7, 0xa9, 0x10, 0x56,
	0x9e, 0x67, 0x43, 0xba, 0x9a, 0x54, 0x39, 0xcf, 0x1b, 0x00, 0xd2, 0xa0, 0x24, 0x90, 0x3f, 0x85,
	0x51, 0xd1, 0x10, 0xf2, 0xa5, 0x1f, 0x58, 0x6d, 0xa7, 0xa0, 0x92, 0x5f, 0xe0, 0x18, 0x2b, 0x14,
	0xa3, 0x82, 0xe6, 0x34, 0x0c, 0x41, 0xc4, 0xd3, 0x9f, 0xea, 0xf8, 0xa8, 0xf4, 0x97, 0xeb, 0x2c,
	0xa9, 0xf4, 0x97, 0x6f, 0x10, 0x39, 0xd3, 0x9f, 0x22, 0xe3, 0x30, 0xaa, 0xdb, 0xa3, 0x60, 0x72,
	0x0d, 0x24, 0x05, 0x93, 0x6f, 0x0e, 0x39, 0x61, 0x14, 0x19, 0xf7, 0x40, 0xbd, 0xcf, 0xa3, 0x3c,
	0xd0, 0xd1, 0x3e, 0x52, 0x1e, 0xe8, 0x6a, 0x0d, 0x39, 0x3d, 0x50, 0x27, 0xe4, 0xe9, 0x50, 0xb6,
	0x7f, 0x7c, 0xe3, 0x0c, 0x0c, 0x57, 0x5f, 0x72, 0xac, 0x14, 0xa4, 0x43, 0x49, 0xc5, 0x6f, 0x72,
	0xad, 0xc9, 0xe3, 0x5b, 0xa7, 0xe0, 0x4e, 0x87, 0xae, 0xae, 0x90, 0xeb, 0x26, 0xd7, 0xe8, 0x08,
	0xd4, 0x01, 0x94, 0x09, 0xb4, 0x3f, 0xa7, 0x8b, 0x2b, 0x98, 0xcf, 0x9b, 0x93, 0x9c, 0x6b, 0x40,
	0xb9, 0xce, 0xa3, 0x69, 0x4b, 0x7c, 0xfe, 0xe2, 0x61, 0x00, 0xea, 0xc5, 0x63, 0x34, 0x8c, 0xd4,
	0x8b, 0xc7, 0x6a, 0xf7, 0xb8, 0x5e, 0x3c, 0x8c, 0x44, 0xf3, 0x24, 0x1e, 0x7f, 0x86, 0x69, 0xcd,
	0xe0, 0x0b, 0x5c, 0x4b, 0x7d, 0x3c, 0x49, 0x85, 0x9d, 0xf4, 0x24, 0xfb, 0x6d, 0xe0, 0x68, 0xf5,
	0xd8, 0x9e, 0x34, 0xc0, 0xdb, 0x40, 0x27, 0xe4, 0xc7, 0xac, 0xd5, 0x74, 0xd5, 0x31, 0xe7, 0x3b,
	0x2c, 0xea, 0x98, 0x1d, 0xbd, 0x0a, 0xe7, 0x31, 0x6b, 0x74, 0x04, 0xaa, 0x07, 0xd3, 0x56, 0xf9,
	0xd8, 0x5f, 0x29, 0xae, 0xd4, 0x07, 0xab, 0xe7, 0xae, 0x73, 0xd8, 0x37, 0x28, 0xec, 0x2a, 0x0a,
	0xdc, 0xb0, 0x84, 0x96, 0xa7, 0x3a, 0x5e, 0xf7, 0x55, 0xa9, 0xce, 0xac, 0x3e, 0xab, 0x54, 0x67,
	0x15, 0x88, 0x9d, 0xa9, 0x8e, 0xd3, 0xf0, 0x50, 0x94, 0x05, 0x4b, 0x15, 0x8a, 0x76, 0x7d, 0x56,
	0x85, 0x62, 0xae, 0xba, 0xe9, 0x0c, 0x45, 0x49, 0x25, 0x1e, 0xbf, 0xa2, 0xd6, 0xa6, 0x3d, 0x7e,
	0xad, 0x12, 0xa4, 0xf6, 0xf8, 0xb5, 0x0b, 0x73, 0xee, 0xc7, 0xaf, 0xa0, 0x22, 0x10, 0xbf, 0x82,
	0x19, 0xbb, 0xd2, 0xe6, 0x6b, 0xc6, 0x77, 0xd6, 0xe7, 0x82, 0xb5, 0xf3, 0x09, 0x38, 0xee, 0x9b,
	0x14, 0x77, 0x0d, 0xdd, 0x32, 0x8e, 0xc7, 0x24, 0x76, 0xc0, 0xd3, 0xef, 0x52, 0x27, 0xbc, 0x56,
	0x7f, 0x73, 0xc3, 0xeb, 0x05, 0xb2, 0xbe, 0xf0, 0x84, 0x98, 0xc0, 0x7f, 0xe6, 0xc1, 0x6c, 0xae,
	0x8a, 0xe3, 0xaf, 0xf5, 0xab, 0x70, 0x05, 0x77, 0xfa, 0x96, 0x80, 0xd0, 0x5b, 0x54, 0x84, 0x3b,
	0x68, 0xd9, 0x14, 0xc1, 0xa4, 0x16, 0x32, 0xd4, 0xce, 0x97, 0xa1, 0xd6, 0x57, 0x86, 0xda, 0x85,
	0x64, 0xa8, 0x39, 0x64, 0xd8, 0x9d, 0xf8, 0xeb, 0xab, 0x15, 0xef, 0x6f, 0xaf, 0x56, 0xbc, 0x7f,
	0xbe, 0x5a, 0xf1, 0x8e, 0x46, 0xe8, 0xff, 0x44, 0xef, 0xfd, 0x37, 0x00, 0x00, 0xff, 0xff, 0xed,
	0x34, 0x52, 0x5d, 0x69, 0x2a, 0x00, 0x00,
}
